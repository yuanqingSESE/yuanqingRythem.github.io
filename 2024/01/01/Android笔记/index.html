<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>
        蒙园青Rythem的博客
    </title>
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-reply replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            Android笔记
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h1 id="Android笔记"><a href="#Android笔记" class="headerlink" title="Android笔记"></a>Android笔记</h1><p>| grep:</p>
<p>| 的意思，不是并行计算，而是 将 前者命令的输出，作为 | 后面命令的输入信息。<br>比如 ps -ef | grep java 不是并行执行的意思，而是 先执行 ps -ef，将输出的内容 xxx 传递给后者，相当于 grep java xxx</p>
<p>响应什么事件，就该为true</p>
<p>XML实现on Click public方法，传参数View</p>
<p>全局变量必须m开头</p>
<p>新建对象，findViewById绑定ID Set如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">View.<span class="type">OnClickListener</span> <span class="variable">clickListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>两种intent方法</p>
<p>隐藏的intent需要传递action，通过广播监听action</p>
<p>Intent 传递数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intent.putExtra(&quot;username&quot;, username.getText());</span><br></pre></td></tr></table></figure>

<p>接收其他Activity通过控件传递的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usernameText.setText(getIntent().getCharSequenceExtra(<span class="string">&quot;username&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>在碎片里调用活动中的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MainActivity</span> <span class="variable">activity</span> <span class="operator">=</span> (MainActivity) getActivity();</span><br></pre></td></tr></table></figure>

<p>设置颜色时在项目中一般这么用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colorView.setBackgroundResource(R.color.green);</span><br></pre></td></tr></table></figure>

<p>1.listView基本使用分三步，1创建一个listView通过findViewByid绑定listView控件2创建adapter引入布局3将adapter，set进listView。</p>
<p>2.使用convertView重用池，不为空的时候重用，checkbox需要监听后根据position赋值避免重用</p>
<p>3.使用viewHolder避免重新创建对象，减少内存占用</p>
<p>4.RecycleView通过linearLayoutManager设置上下或者左右滑动</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">refs/for/[brach] 需要经过code review之后才可以提交，而refs/heads/[beanch]不需要code review。</span><br></pre></td></tr></table></figure>

<p>ANR：</p>
<p>不要把耗时处理放在UI主线程。</p>
<p>死锁导致ANR，检查主线程是否需要这个锁。</p>
<h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>MVC中View和Controller操作在Activity和Fragment中实现，而MVP将MVC中的Controller变为Presenter。View与Model隔离，Presenter负责完成View层与Model的交互，Controller层响应用户输入进行逻辑处理。</p>
<p><img src="/typora-user-images/image-20250109214842503.png" alt="MVVM"></p>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p> 在MVP的基础上实现数据双向绑定</p>
<p>Activity和Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ActivityMainBinding binding;</span><br><span class="line">Account yest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    binding =</span><br><span class="line">            DataBindingUtil.setContentView(<span class="built_in">this</span>, R.layout.activity_main);</span><br><span class="line">    yest = <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="string">&quot;YEST&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    binding.setAccount(yest);</span><br><span class="line">    binding.setActivity(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onclick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> yest.getLevel();</span><br><span class="line">    yest.setLevel(level+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thundersoft.mvx.data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.databinding.BaseObservable;</span><br><span class="line"><span class="keyword">import</span> androidx.databinding.Bindable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.thundersoft.mvx.BR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> <span class="keyword">extends</span> <span class="title class_">BaseObservable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> Level;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String name, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        Level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bindable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLevel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLevel</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">        Level = level;</span><br><span class="line">        notifyPropertyChanged(BR.level);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>xml:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">name</span>=<span class="string">&quot;account&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">type</span>=<span class="string">&quot;com.thundersoft.mvx.data.Account&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">name</span>=<span class="string">&quot;activity&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">type</span>=<span class="string">&quot;com.thundersoft.mvx.data.MainActivity&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">tools:context</span>=<span class="string">&quot;.mvp.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:id</span>=<span class="string">&quot;@+id/mEtInput&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:id</span>=<span class="string">&quot;@+id/mBtnGet&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;activity.onclick&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:text</span>=<span class="string">&quot;获取账号信息&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:id</span>=<span class="string">&quot;@+id/mTvInfo&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:text</span>=<span class="string">&quot;@&#123;account.name+&#x27;|&#x27;+account.level&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h2><p>进程的内存大小是有限制的，使用如下命令查看进程间内存大小限制。超过会报错om，如下情况可单独起一个进程</p>
<p>adb shell</p>
<p>getprop dalvik.vm.heapsize</p>
<ul>
<li>占用内存的模块；</li>
<li>需要独立通信进程保持长连接的稳定性；</li>
<li>webView很容易内存泄露，webView不用的话直接将进程给Kill掉；</li>
<li>不稳定的功能放入独立进程；</li>
</ul>
<p>Binder可以为每个APP分配UID同时支持实名和匿名，去ServiceManager注册的是实名，没去的是匿名，系统服务是实名，个人服务是匿名。</p>
<p>进程间通信和线程间通信的内存机制不同，进程间通信是不共享内存的，线程间通信是共享内存的。</p>
<p>AIDL中Interface方法通过DESCRIPTOR判断如果是同一进程，那么就返回Stub对象本身(obj.queryLocalInterface(DESCRIPTOR))，否则如果是跨进程则返回Stub的代理内部类Proxy。</p>
<p><img src="/typora-user-images/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1.png" alt="进程通信"></p>
<p><img src="/typora-user-images/binder.png" alt="binder"></p>
<h2 id="Android启动模式"><a href="#Android启动模式" class="headerlink" title="Android启动模式"></a>Android启动模式</h2><p>standard：不断启动新的Activity实例，在OneActivity通过StartActivity启动OneActivity，返回栈中会有两个OneActivity，按下两次back才会回到home界面。</p>
<p>singleTop：如果当前返回栈的栈顶为当前实例不会在继续创建，在OneActivity通过StartActivity启动OneActivity，按下一次back直接回到home界面。</p>
<p>singleTask：创建实例时，如果当前返回栈中存在当前实例，那么不会在继续创建，并且在这个实例之上的实例会统统出栈。</p>
<p>singleInstance：指定这种启动方式的Activity， 在创建实例时，自己拥有一个返回栈。</p>
<h2 id="Android消息机制"><a href="#Android消息机制" class="headerlink" title="Android消息机制"></a>Android消息机制</h2><p>​        通常handler会被认为更新UI，因为我们不能再子线程中访问UI控件，否则就会触发程序异常，这个时候通过Handler就可以将更新UI的操作切换到主线程中执行。</p>
<p>​        MessageQueue内部存储结构并不是真正的队列，而是采用单链表的数据结构来存储消息列表。Looper的意思是循环。由于MessageQueue只是一个消息的存储单元，它不能去处理消息，而Looper就填补了这个功能，Looper会以无限循环的形式去查找是否有新消息，如果有的话就处理消息，否则就一直等待着。Looper中还有一个特殊的概念，那就是ThreadLocal，ThreadLocal并不是线程，它的作用是可以在每个线程中存储数据。Handler创建的时候会采用当前线程的Looper来构造消息循环系统，那么Handler内部如何获取到当前线程的Looper呢？这就要使用ThreadLocal了，ThreadLocal可以在不同的线程中互不干扰地存储并提供数据，通过ThreadLocal可以轻松获取每个线程的Looper。要注意，线程默认是没有Looper的，如果需要使用Handler就必须为线程创建Looper。我们经常提到的主线程，也就是UI线程，它是ActivityThread，ActivityThread被创建时就会初始化Looper，这也是在主线程中默认可以使用Handler的原因。</p>
<p>​        Handler的主要作用是将一个任务切换到某个指定的线程中去执行。Android为什么要提供这个功能呢？这是因为Android规定访问UI只能在主线程中进行，如果在子线程中访问UI，那么程序就会抛出异常。基于此必须要在主线程中访问UI，但Android又不建议在主线程中进行耗时操作，否则会导致程序无法响应即ANR，假如要从服务端拉取信息并显示在UI上，这个时候必须在子线程中进行拉取工作，拉取完毕后又不能在子线程中直接访问UI，如果没有Handler，那么我们的确没有办法将访问UI的工作切换到主线程中，系统之所以提供Handler，主要原因就是为了解决在子线程中无法访问UI的矛盾。</p>
<p>​        这里再延伸一点，系统为什么不允许在子线程中访问UI呢？这是因为Android的UI控件不是线程安全的，如果在多线程中并发访问可能会导致UI控件处于不可预期的状态，那为什么系统不对UI控件的访问加上锁机制呢？缺点有两个：首先加上锁机制会让UI访问的逻辑变得复杂；其次锁机制会降低UI访问的效率，因为锁机制会阻塞某些线程的执行。鉴于这两个缺点，最简单且高效的方法就是采用单线程模型来处理UI操作，对于开发者来说也不是很麻烦，只是需要通过Handler切换一下UI访问的执行线程即可。</p>
<p>​        Handler的使用方法这里就不做介绍了，这里描述一下Handler的工作原理。Handler创建时会采用当前线程的Looper来构建内部的消息循环系统，如果当前线程没有Looper，那么就会报错，如下所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E/AndroidRuntime(27568): FATAL EXCEPTION: Thread-43484</span><br><span class="line">E/AndroidRuntime(27568): java.lang.RuntimeException: Can&#x27;t create handler  inside thread that has not called Looper.prepare()</span><br><span class="line">E/AndroidRuntime(27568): at android.os.Handler.&lt;init&gt;(Handler.java:121)</span><br><span class="line">E/AndroidRuntime(27568): at com.ryg.chapter_10.TestActivity$3.run(TestActivity.java:57)</span><br></pre></td></tr></table></figure>

<p>只需要为当前线程创建Looper即可，或者在一个有Looper的线程中创建Handler也行</p>
<p>Handler的post方法将一个Runnable投递到Handler内部的Looper中去处理，也可以通过Handler的send方法发送一个消息，这个消息同样会在Looper中去处理。post方法也是通过send方法来完成的。当Handler的send方法被调用时，它会调用MessageQueue的enqueueMessage方法将这个消息放入消息队列中，然后Looper发现有新消息到来时，就会处理这个消息，最终消息中的Runnable或者Handler的handleMessage方法就会被调用。注意Looper是运行在创建Handler所在的线程中的，这样一来Handler中的业务逻辑就被切换到创建Handler所在的线程中去执行了</p>
<p><img src="/typora-user-images/image-20211020173428649.png" alt="image-20211020173428649"></p>
<h3 id="ThreadLocal工作原理"><a href="#ThreadLocal工作原理" class="headerlink" title="ThreadLocal工作原理"></a>ThreadLocal工作原理</h3><p>当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用ThreadLocal。比如对于Handler来说，它需要获取当前线程的Looper，很显然Looper的作用域就是线程并且不同线程具有不同的Looper，这个时候通过ThreadLocal就可以轻松实现Looper在线程中的存取。可以使用ThreadLocal当做监视器贯穿整个线程的执行过程，如果不使用ThreadLocal，可以有以下两种方法</p>
<ul>
<li>将监视器通过参数的形式在函数调用栈中进行传递。</li>
</ul>
<p>当函数调用栈很深的时候，通过函数参数来传递监听器对象这几乎是不可接受的，这会让程序的设计看起来很糟糕。</p>
<ul>
<li>将监视器作为静态遍历供线程访问。</li>
</ul>
<p>这种方法可接受但不是可扩充性的，比如同时有两个线程在执行，那么就需要提供两个静态的监听器对象，如果有10个线程在并发执行呢？提供10个静态的监听器对象？</p>
<p>具体示例：</p>
<p>定义一个ThreadLocal对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ThreadLocal&lt;Boolean&gt; mBooleanThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Boolean&gt;();</span><br></pre></td></tr></table></figure>

<p>然后分别在主线程、子线程1和子线程2中设置和访问它的值，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mBooleanThreadLocal.set(<span class="literal">true</span>);</span><br><span class="line">    Log.d(TAG,<span class="string">&quot;[Thread#main]mBooleanThreadLocal=&quot;</span> + mBooleanThreadLocal.get());</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;Thread#1&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                mBooleanThreadLocal.set(<span class="literal">false</span>);</span><br><span class="line">                Log.d(TAG,<span class="string">&quot;[Thread#1]mBooleanThreadLocal=&quot;</span> + mBooleanThreadLocal.get());</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;.start();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;Thread#2&quot;</span>) &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">               Log.d(TAG,<span class="string">&quot;[Thread#2]mBooleanThreadLocal=&quot;</span> + mBooleanThreadLocal.get());</span><br><span class="line">       &#125;;</span><br><span class="line">   &#125;.start();</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，在主线程中设置mBooleanThreadLocal的值为true，在子线程1中设置mBooleanThreadLocal的值为false，在子线程2中不设置mBooleanThreadLocal的值。然后分别在3个线程中通过get方法获取mBooleanThreadLocal的值，根据前面对ThreadLocal的描述，这个时候，主线程中应该是true，子线程1中应该是false，而子线程2中由于没有设置值，所以应该是null。安装并运行程序，日志如下所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D/TestActivity(8676): [Thread#main]mBooleanThreadLocal=true</span><br><span class="line">D/TestActivity(8676): [Thread#1]mBooleanThreadLocal=false</span><br><span class="line">D/TestActivity(8676): [Thread#2]mBooleanThreadLocal=null</span><br></pre></td></tr></table></figure>

<p>ThreadLocal之所以有这么奇妙的效果，是因为不同线程访问同一个ThreadLocal的get方法，ThreadLocal内部会从各自的线程中取出一个数组，然后再从数组中根据当前ThreadLocal的索引去查找出对应的value值。很显然，不同线程中的数组是不同的，这就是为什么通过ThreadLocal可以在不同的线程中维护一套数据的副本并且彼此互不干扰。</p>
<p>ThreadLocal是一个泛型类，它的定义为public class ThreadLocal<T>，只要弄清楚ThreadLocal的get和set方法就可以明白他的工作原理</T></p>
<p>JDK1.8前：</p>
<ul>
<li><p>set方法中，首先会通过values方法来获取当前线程中的ThreadLocal数据，如何获取呢？其实获取的方式也是很简单的，在Thread类的内部有一个成员专门用于存储线程的ThreadLocal的数据：ThreadLocal.Values localValues，因此获取当前线程的ThreadLocal数据就变得异常简单了。如果localValues的值为null，那么就需要对其进行初始化，初始化后再将ThreadLocal的值进行存储。下面看一下ThreadLocal的值到底是如何在localValues中进行存储的。在localValues内部有一个数组：private Object[] table，ThreadLocal的值就存在在这个table数组中。ThreadLocal的值在table数组中的存储位置总是为ThreadLocal的reference字段所标识的对象的下一个位置，比如ThreadLocal的reference对象在table数组中的索引为index，那么ThreadLocal的值在table数组中的索引就是index+1。最终ThreadLocal的值将会被存储在table数组中：table[index + 1] &#x3D; value。</p>
</li>
<li><p>调用get方法它同样是取出当前线程的local-Values对象，如果这个对象为null那么就返回初始值，初始值由ThreadLocal的initialValue方法来描述</p>
</li>
<li><p>那么我们可以知道在使用ThreadLocal时他是将对象存储到数组的table[index]中，将实际的值存到table[index+1]中。</p>
</li>
</ul>
<h3 id="消息队列的工作原理"><a href="#消息队列的工作原理" class="headerlink" title="消息队列的工作原理"></a>消息队列的工作原理</h3><p>消息队列在Android中指的是MessageQueue，MessageQueue主要包含两个操作：插入和读取。读取操作本身会伴随着删除操作，插入和读取对应的方法分别为enqueueMessage和next，其中enqueueMessage的作用是往消息队列中插入一条消息，而next的作用是从消息队列中取出一条消息并将其从消息队列中移除。尽管MessageQueue叫消息队列，但是它的内部实现并不是用的队列，实际上它是通过一个单链表的数据结构来维护消息列表，单链表在插入和删除上比较有优势。</p>
<p>next方法是一个无限循环的方法，如果消息队列中没有消息，那么next方法会一直阻塞在这里。当有新消息到来时，next方法会返回这条消息并将其从单链表中移除。</p>
<h3 id="Looper的工作原理"><a href="#Looper的工作原理" class="headerlink" title="Looper的工作原理"></a>Looper的工作原理</h3><p>Looper在Android的消息机制中扮演着消息循环的角色，具体来说就是它会不停地从MessageQueue中查看是否有新消息，如果有新消息就会立刻处理，否则就一直阻塞在那里。首先看一下它的构造方法，在构造方法中它会创建一个MessageQueue即消息队列，然后将当前线程的对象保存起来，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Looper</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">        mQueue = <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(quitAllowed);</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Handler的工作需要Looper，没有Looper的线程就会报错，那么如何为一个线程创建Looper呢？其实很简单，通过Looper.prepare()即可为当前线程创建一个Looper，接着通过Looper.loop()来开启消息循环，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ew <span class="title function_">Thread</span><span class="params">(<span class="string">&quot;Thread#2&quot;</span>)</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                Looper.prepare();</span><br><span class="line">                <span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>();</span><br><span class="line">                Looper.loop();</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;.start();</span><br></pre></td></tr></table></figure>

<p>Looper除了prepare方法外，还提供了prepareMainLooper方法，这个方法主要是给主线程也就是ActivityThread创建Looper使用的，其本质也是通过prepare方法来实现的。由于主线程的Looper比较特殊，所以Looper提供了一个getMainLooper方法，通过它可以在任何地方获取到主线程的Looper。Looper也是可以退出的，Looper提供了quit和quitSafely来退出一个Looper，二者的区别是：quit会直接退出Looper，而quitSafely只是设定一个退出标记，然后把消息队列中的已有消息处理完毕后才安全地退出。Looper退出后，通过Handler发送的消息会失败，这个时候Handler的send方法会返回false。在子线程中，如果手动为其创建了Looper，那么在所有的事情完成以后应该调用quit方法来终止消息循环，否则这个子线程就会一直处于等待的状态，而如果退出Looper以后，这个线程就会立刻终止，因此建议不需要的时候终止Looper。</p>
<p>Looper最重要的方法是loop方法，调用loop后，调用loop后消息循环系统才会真正的起作用。</p>
<p>Looper的loop方法的工作过程也比较好理解，loop方法是一个死循环，唯一跳出循环的方式是MessageQueue的next方法返回了null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> queue.next(); <span class="comment">// might block</span></span><br><span class="line">    <span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当Looper的quit方法被调用时，Looper就会调用MessageQueue的quit或者quitSafely方法来通知消息队列退出，当消息队列被标记为退出状态时，它的next方法就会返回null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quit</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mQueue.quit(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quitSafely</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mQueue.quit(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，Looper必须退出，否则loop方法就会无限循环下去。loop方法会调用MessageQueue的next方法来获取新消息，而next是一个阻塞操作，当没有消息时，next方法会一直阻塞在那里，这也导致loop方法一直阻塞在那里。如果MessageQueue的next方法返回了新消息，Looper就会处理这条消息：msg.target.dispatchMessage(msg)，这里的msg.target是发送这条消息的Handler对象，这样Handler发送的消息最终又交给它的dispatchMessage方法来处理了。但是这里不同的是，Handler的dispatchMessage方法是在创建Handler时所使用的Looper中执行的，这样就成功地将代码逻辑切换到指定的线程中去执行了。</p>
<h3 id="Handler的工作原理"><a href="#Handler的工作原理" class="headerlink" title="Handler的工作原理"></a>Handler的工作原理</h3><p>Handler的工作主要包含消息的发送和接收过程，发送的post一系列方法，最终是通过send的一系列方法来实现的。</p>
<p>Handler发送消息的过程仅仅是向消息队列中插入了一条消息，MessageQueue的next方法就会返回这条消息给Looper，Looper收到消息后就开始处理了，最终消息由Looper交由Handler处理，即Handler的dispatchMessage方法会被调用，这时Handler就进入了处理消息的阶段。</p>
<p>dispatchMessage的实现如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatchMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="literal">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.mCallback != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.mCallback.handleMessage(msg)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，检查Message的callback是否为null，不为null就通过handleCallback来处理消息。Message的callback是一个Runnable对象，实际上就是Handler的post方法所传递的Runnable参数。</p>
<p>handleCallback逻辑很简单如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleCallback</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">    message.callback.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，检查mCallback是否为null，不为null就调用mCallback的handleMessage方法来处理消息。Callback是个接口，它的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">handleMessage</span><span class="params">(Message var1)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过Callback可以采用如下方式来创建Handler对象：Handler handler &#x3D; new Handler(callback)。那么Callback的意义是什么呢？源码里面的注释已经做了说明：可以用来创建一个Handler的实例但并不需要派生Handler的子类。在日常开发中，创建Handler最常见的方式就是派生一个Handler的子类并重写其handleMessage方法来处理具体的消息，而Callback给我们提供了另外一种使用Handler的方式，当我们不想派生子类时，就可以通过Callback来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(<span class="keyword">new</span> <span class="title class_">Handler</span>.Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handleMessage</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="/typora-user-images/handler%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="handler流程图"></p>
<p>handler也可以使用特定的Looper来构造</p>
<p>Handler的无参构造方法会检查当前线程没有Looper的话抛出”Can’t create handler inside thread that has not called Looper.prepare()”的运行时异常。</p>
<h3 id="主线程消息循环"><a href="#主线程消息循环" class="headerlink" title="主线程消息循环"></a>主线程消息循环</h3><p>Android的主线程就是ActivityThread，主线程的入口方法为main，在main方法中系统会通过Looper.prepareMainLooper()来创建主线程的Looper以及MessageQueue，并通过Looper.loop()来开启主线程的消息循环，这个过程如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SamplingProfilerIntegration.start();</span><br><span class="line">    ...</span><br><span class="line">    Process.setArgV0(<span class="string">&quot;&lt;pre-initialized&gt;&quot;</span>);</span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    <span class="type">ActivityThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityThread</span>();</span><br><span class="line">    thread.attach(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主线程的消息循环开始了以后，ActivityThread还需要一个Handler来和消息队列进行交互，这个Handler就是ActivityThread.H，它内部定义了一组消息类型，主要包含了四大组件的启动和停止等过程。</p>
<p>ActivityThread通过ApplicationThread和AMS进行进程间通信，AMS以进程间通信的方方式完成ActivityThread的请求后会回调ApplicationThread中的Binder方法，然后ApplicationThread会向H发送消息，H收到消息后会将ApplicationThread中的逻辑切换到ActivityThread中去执行，即切换到主线程中去执行，这个过程就是主线程的消息循环模型。</p>
<h3 id="Handler基本结构已经了解完毕那么一定会有如下三个问题"><a href="#Handler基本结构已经了解完毕那么一定会有如下三个问题" class="headerlink" title="Handler基本结构已经了解完毕那么一定会有如下三个问题"></a>Handler基本结构已经了解完毕那么一定会有如下三个问题</h3><p>1.Android中为什么主线程不会因为Looper.loop()里的死循环卡死？ </p>
<p>这里涉及线程，先说说说进程&#x2F;线程，<strong>进程</strong>：每个app运行时前首先创建一个进程，该进程是由Zygote fork出来的，用于承载App上运行的各种Activity&#x2F;Service等组件。进程对于上层应用来说是完全透明的，这也是google有意为之，让App程序都是运行在Android Runtime。大多数情况一个App就运行在一个进程中，除非在AndroidManifest.xml中配置Android:process属性，或通过native代码fork进程。</p>
<p><strong>线程</strong>： 线程对应用来说非常常见，比如每次new Thread().start都会创建一个新的线程。该线程与App所在进程之间资源共享，从Linux角度来说进程与线程除了是否共享资源外，并没有本质的区别，都是一个task_struct结构体，<strong>在CPU看来进程或线程无非就是一段可执行的代码，CPU采用CFS调度算法，保证每个task都尽可能公平的享有CPU时间片</strong>。</p>
<p>有了这么准备，再说说死循环问题:</p>
<p>对于线程既然是一段可执行的代码，当可执行代码执行完成后，线程生命周期便该终止了，线程退出。而对于主线程，我们是绝不希望会被运行一段时间，自己就退出，那么如何保证能一直存活呢？<strong>简单做法就是可执行代码是能一直执行下去的，死循环便能保证不会被退出</strong>，例如，<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=31574662&content_type=Answer&match_order=1&q=binder%E7%BA%BF%E7%A8%8B&zhida_source=entity">binder线程</a>也是采用死循环的方法，通过循环方式不同与Binder驱动进行读写操作，当然并非简单地死循环，无消息时会休眠。但这里可能又引发了另一个问题，既然是死循环又如何去处理其他事务呢？通过创建新线程的方式。</p>
<p>真正会卡死主线程的操作是在回调方法onCreate&#x2F;onStart&#x2F;onResume等操作时间过长，会导致掉帧，甚至发生ANR，looper.loop本身不会导致应用卡死。</p>
<p>2.没看见哪里有相关代码为这个死循环准备了一个新线程去运转？ </p>
<p>事实上，会在进入死循环之前便创建了新binder线程，在代码ActivityThread.main()中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ....</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Looper和MessageQueue对象，用于处理主线程的消息</span></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建ActivityThread对象</span></span><br><span class="line">        <span class="type">ActivityThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityThread</span>(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">//建立Binder通道 (创建新线程)</span></span><br><span class="line">        thread.attach(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        Looper.loop(); <span class="comment">//消息循环运行</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>thread.attach(false)；便会创建一个Binder线程（具体是指ApplicationThread，Binder的服务端，用于接收系统服务AMS发送来的事件），该binder线程通过Handler将Message发送给主线程</strong>，例如看下结尾的Android系统个人总结</p>
<p>另外，<strong>ActivityThread实际上并非线程</strong>，不像HandlerThread类，ActivityThread并没有真正继承Thread类，只是往往运行在主线程，该人以线程的感觉，其实承载ActivityThread的主线程就是由Zygote fork而创建的进程。</p>
<p><strong>主线程的死循环一直运行是不是特别消耗CPU资源呢？</strong> 其实不然，这里就涉及到<strong>Linux pipe&#x2F;epoll机制</strong>，简单说就是在主线程的MessageQueue没有消息时，便阻塞在loop的queue.next()中的nativePollOnce()方法里，此时主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作。这里采用的epoll机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I&#x2F;O，即读写是阻塞的。 <strong>所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源</strong>。</p>
<p> “一般的死循环会让程序卡死，比如 while(true) 打印hello，打印到天荒地老” 这不就卡死了吗。</p>
<p>另外 没有这个 唤醒机制 那主线程不就成了一次性的了？</p>
<p>3.Activity的生命周期这些方法这些都是在主线程里执行的吧，那这些生命周期方法是怎么实现在死循环体外能够执行起来的？</p>
<p>ActivityThread的内部类H继承于Handler，通过handler消息机制，简单说Handler机制用于同一个进程的线程间通信。</p>
<p><strong>Activity的生命周期都是依靠主线程的Looper.loop，当收到不同Message时则采用相应措施</strong>：</p>
<p>在H.handleMessage(msg)方法中，根据接收到不同的msg，执行相应的生命周期。</p>
<p>比如收到msg&#x3D;H.LAUNCH_ACTIVITY，则调用ActivityThread.handleLaunchActivity()方法，最终会通过<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=31574662&content_type=Answer&match_order=1&q=%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6&zhida_source=entity">反射机制</a>，创建Activity实例，然后再执行Activity.onCreate()等方法；</p>
<p>再比如收到msg&#x3D;H.PAUSE_ACTIVITY，则调用ActivityThread.handlePauseActivity()方法，最终会执行Activity.onPause()等方法。 上述过程，只说核心逻辑讲，真正该过程远比这复杂。</p>
<p><strong>主线程的消息又是哪来的呢</strong>？当然是App进程中的其他线程通过Handler发送给主线程，请看接下来的内容：</p>
<p><img src="/typora-user-images/7fb8728164975ac86a2b0b886de2b872_r.jpg"></p>
<p><strong><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=31574662&content_type=Answer&match_order=1&q=system_server%E8%BF%9B%E7%A8%8B&zhida_source=entity">system_server进程</a>是系统进程</strong>，java framework框架的核心载体，里面运行了大量的系统服务，比如这里提供ApplicationThreadProxy（简称ATP），ActivityManagerService（简称AMS），这个两个服务都运行在system_server进程的不同线程中，由于ATP和AMS都是基于IBinder接口，都是binder线程，binder线程的创建与销毁都是由binder驱动来决定的。</p>
<p><strong>App进程则是我们常说的应用程序</strong>，主线程主要负责Activity&#x2F;Service等组件的生命周期以及UI相关操作都运行在这个线程； 另外，每个App进程中至少会有两个binder线程 ApplicationThread(简称AT)和ActivityManagerProxy（简称AMP），除了图中画的线程，其中还有很多线程，比如signal catcher线程等，这里就不一一列举。</p>
<p>Binder用于不同进程之间通信，由一个进程的Binder客户端向另一个进程的服务端发送事务，比如图中线程2向线程4发送事务；而handler用于同一个进程中不同线程的通信，比如图中线程4向主线程发送消息。</p>
<p><strong>结合图说说Activity生命周期，比如暂停Activity，流程如下</strong>：</p>
<ol>
<li>线程1的AMS中调用线程2的ATP；（由于同一个进程的线程间资源共享，可以相互直接调用，但需要注意多线程并发问题）</li>
<li>线程2通过binder传输到App进程的线程4；</li>
<li>线程4通过handler消息机制，将暂停Activity的消息发送给主线程；</li>
<li>主线程在looper.loop()中循环遍历消息，当收到暂停Activity的消息时，便将消息分发给ActivityThread.H.handleMessage()方法，再经过方法的调用，最后便会调用到Activity.onPause()，当onPause()处理完后，继续循环loop下去。</li>
</ol>
<h3 id="Android线程和线程池"><a href="#Android线程和线程池" class="headerlink" title="Android线程和线程池"></a>Android线程和线程池</h3><p>线程分为主线程和子线程，主线程主要处理和界面相关的事情，而子线程则往往用于执行耗时操作。由于Android的特性，如果在主线程中执行耗时操作那么就会导致程序无法及时地响应，因此耗时操作必须放在子线程中去执行。</p>
<p>HandlerThread是一种具有消息循环的线程，在它的内部可以使用Handler。IntentService是一个服务，系统对其进行了封装使其可以更方便地执行后台任务，IntentService内部采用HandlerThread来执行任务，当任务执行完毕后IntentService会自动退出。从任务执行的角度来看，IntentService的作用很像一个后台线程，但是IntentService是一种服务，它不容易被系统杀死从而可以尽量保证任务的执行，而如果是一个后台线程，由于这个时候进程中没有活动的四大组件，那么这个进程的优先级就会非常低，会很容易被系统杀死，这就是IntentService的优点。</p>
<p>在操作系统中，线程是操作系统调度的最小单元，同时线程又是一种受限的系统资源，即线程不可能无限制地产生，并且线程的创建和销毁都会有相应的开销。当系统中存在大量的线程时，系统会通过时间片轮转的方式调度每个线程，因此线程不可能做到绝对的并行，除非线程数量小于等于CPU的核心数，一般来说这是不可能的。试想一下，如果在一个进程中频繁地创建和销毁线程，这显然不是高效的做法。正确的做法是采用线程池，一个线程池中会缓存一定数量的线程，通过线程池就可以避免因为频繁创建和销毁线程所带来的系统开销。</p>
<ul>
<li>HandlerThread</li>
</ul>
<p>HandlerThread继承了Thread，它是一种可以使用Handler的Thread，它的实现也很简单，就是在run方法中通过Looper.prepare()来创建消息队列，并通过Looper.loop()来开启消息循环，这样在实际的使用中就允许在HandlerThread中创建Handler了。run方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mTid = Process.myTid();</span><br><span class="line">    Looper.prepare();</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.mLooper = Looper.myLooper();</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Process.setThreadPriority(<span class="built_in">this</span>.mPriority);</span><br><span class="line">    <span class="built_in">this</span>.onLooperPrepared();</span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="built_in">this</span>.mTid = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从HandlerThread的实现来看，它和普通的Thread有显著的不同之处。普通Thread主要用于在run方法中执行一个耗时任务，而HandlerThread在内部创建了消息队列，外界需要通过Handler的消息方式来通知HandlerThread执行一个具体的任务。HandlerThread是一个很有用的类，它在Android中的一个具体的使用场景是IntentService，由于HandlerThread的run方法是一个无限循环，因此当明确不需要再使用HandlerThread时，可以通过它的quit或者quitSafely方法来终止线程的执行，这是一个良好的编程习惯。</p>
<ul>
<li>IntentService</li>
</ul>
<p>IntentService是一种特殊的Service，它继承了Service并且它是一个抽象类，因此必须创建它的子类才能使用IntentService。IntentService可用于执行后台耗时的任务，当任务执行后它会自动停止，同时由于IntentService是服务的原因，这导致它的优先级比单纯的线程要高很多，所以IntentService比较适合执行一些高优先级的后台任务，因为它优先级高不容易被系统杀死。在实现上，IntentService封装了HandlerThread和Handler，这一点可以从它的onCreate方法中看出来，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate();</span><br><span class="line">    <span class="type">HandlerThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerThread</span>(<span class="string">&quot;IntentService[&quot;</span> + <span class="built_in">this</span>.mName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    thread.start();</span><br><span class="line">    <span class="built_in">this</span>.mServiceLooper = thread.getLooper();</span><br><span class="line">    <span class="built_in">this</span>.mServiceHandler = <span class="keyword">new</span> <span class="title class_">IntentService</span>.ServiceHandler(<span class="built_in">this</span>.mServiceLooper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当IntentService被第一次启动时，它的onCreate方法会被调用，onCreate方法会创建一个HandlerThread，然后使用它的Looper来构造一个Handler对象mServiceHandler，这样通过mServiceHandler发送的消息最终都会在HandlerThread中执行，从这个角度来看，IntentService也可以用于执行后台任务。每次启动IntentService，它的onStartCommand方法就会调用一次，IntentService在onStartCommand中处理每个后台任务的Intent。下面看一下onStartCommand方法是如何处理外界的Intent的，onStartCommand调用了onStart，onStart方法的实现如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(Intent intent, <span class="type">int</span> startId)</span> &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="built_in">this</span>.mServiceHandler.obtainMessage();</span><br><span class="line">    msg.arg1 = startId;</span><br><span class="line">    msg.obj = intent;</span><br><span class="line">    <span class="built_in">this</span>.mServiceHandler.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="填坑记"><a href="#填坑记" class="headerlink" title="填坑记"></a>填坑记</h1><p>多线程中使用递归出现问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colorView.setBackgroundColor(<span class="number">0xffff0000</span>);</span><br></pre></td></tr></table></figure>

<p>此方法使用ARGB，0X             FF            FF              FF           00</p>
<p>​                                               透明度         R               G             B</p>
<p>在调用tabLayout.setupWithViewPager(viewPager);会出现没有Tab的情况</p>
<p>因为setupWithViewPager(viewPager)会调用removeAllTabs()，移除全部的Tab</p>
<p>之前向TabLayout添加的Tab项调用这个方法后都被移除了，它会重新创建新的Tab项，tab显示的文字是从适配器getPageTitle()获取的 。上面我们写适配器的时候没有重写适配器的getPageTitle()方法 ，所以效果就是有Tab项但Tab项上没有文字了，解决办法就是重写适配器的getPageTitle()方法</p>
<p>解决办法：</p>
<p>1.在Adapter中重写方法重新给TableLayout赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CharSequence <span class="title function_">getPageTitle</span><span class="params">(<span class="type">int</span> position)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MainActivity.mTitles[position];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.可以执行完setupWithViewPager（）后，再添加标题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tabLayout.setupWithViewPager(allArtPager);</span><br><span class="line">tabLayout.getTabAt(<span class="number">0</span>).setText(<span class="string">&quot;全部&quot;</span>);</span><br><span class="line">tabLayout.getTabAt(<span class="number">1</span>).setText(<span class="string">&quot;Ping²it&quot;</span>);</span><br><span class="line">tabLayout.getTabAt(<span class="number">2</span>).setText(<span class="string">&quot;同款&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>出现异常java.lang.NullPointerException: Attempt to invoke virtual method ‘void android.widget.TextView.setText(java.lang.CharSequence)’ on a null object reference</p>
<p>查看 当前inflate的layout是否含有frag_text。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> inflater.inflate(R.layout.text_color, container, <span class="literal">false</span>);</span><br><span class="line"><span class="type">TextView</span> <span class="variable">textView</span> <span class="operator">=</span> view.findViewById(R.id.frag_text);</span><br></pre></td></tr></table></figure>

<p>要先如果在收到广播消息的onReceive的方法中去为控件赋值，是无法赋值的，即使赋值也是在DetailActivity.class启动前赋值，跳转后无法接收。</p>
<p>要先跳转到DetailActivity在通过Bundle把对象取出进行赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例化IntentFilter对象</span></span><br><span class="line">    <span class="type">IntentFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntentFilter</span>();</span><br><span class="line">    filter.addAction(Common.INFO);</span><br><span class="line">    DetailActivity.class</span><br><span class="line">    <span class="comment">//注册广播接收</span></span><br><span class="line">    <span class="type">DynamicReceiver</span> <span class="variable">dynamicReceiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DynamicReceiver</span>();</span><br><span class="line">    registerReceiver(dynamicReceiver, filter);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicReceiver</span> <span class="keyword">extends</span> <span class="title class_">BroadcastReceiver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> &#123;</span><br><span class="line">        Toast.makeText(getApplication(), <span class="string">&quot;接收广播：&quot;</span> + intent.getStringExtra(Common.INFO), Toast.LENGTH_SHORT).show();</span><br><span class="line">        intent.setClass(MainActivity.<span class="built_in">this</span>, DetailActivity.class);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个simple_list_item_1是SDK自有的布局，如果在构造Adapter的时候传自己定义布局可能会报</span></span><br><span class="line"><span class="comment">// ArrayAdapter requires the resource ID to be a TextView</span></span><br><span class="line">arrayAdapter = <span class="keyword">new</span> <span class="title class_">ArrayAdapter</span>&lt;String&gt;(<span class="built_in">this</span>, android.R.layout.simple_list_item_1, contactsList);</span><br></pre></td></tr></table></figure>

<p>天坑问题：使用AIDL配置Service，一定要核对包名也就是package！如果包名不对会连接不到服务，如果.不出来（也就是android:name&#x3D;需要写全部路径）证明包名不对，服务肯定无法连接。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.aidl.service&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.Aidl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.PersonService&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>开发相册删除时在相对布局中，RecyclerView的Item布局，layout_width和layout_height设置为warp_content,蒙版ImageView控件需要设置为定值</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.hryt.design.base.HHRelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;warp_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;warp_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">com.hryt.design.base.HHImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/image_mask&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;@dimen/item_album_list_image_width&quot;</span>  <span class="attr">定值</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;@dimen/item_album_list_image_height&quot;</span>  <span class="attr">定值</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;@color/image_mask_color&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:visibility</span>=<span class="string">&quot;gone&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果出现蒙版后挡住checkbox,可以调节layoutxml的位置，让蒙版控件在checkbox之前</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.hryt.design.base.HHImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/image_mask&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;@dimen/item_album_list_image_width&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;@dimen/item_album_list_image_height&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;@color/image_mask_color&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:visibility</span>=<span class="string">&quot;gone&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">com.hryt.design.checkbox.v2.HHCheckBox</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/item_select_chk&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_alignRight</span>=<span class="string">&quot;@+id/imageView&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_alignBottom</span>=<span class="string">&quot;@id/imageView&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:singleLine</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>项目中，由于同时选中收藏相册，和普通相册，而收藏相册里的图片是基于普通相册的，会进行两次回调，用于通知用户是否删除成功，那么如何解决</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteSuccessResetView</span><span class="params">(List&lt;DeleteResult&gt; deleteResults)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断如果选中的相册中包含删除并且数量为两个以上。</span></span><br><span class="line">    ArrayList&lt;AlbumListBean&gt; selectAlbumItems = findSelectAlbumItems();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isCollect</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (selectAlbumItems.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (AlbumListBean selectAlbumItem : selectAlbumItems) &#123;</span><br><span class="line">            <span class="keyword">if</span> (selectAlbumItem.getType() == DeviceItem.DEVICE_TYPE_COLLECT) &#123;</span><br><span class="line">                isCollect = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为如果选中收藏相册，和普通相册那么一定会回调两次。</span></span><br><span class="line">    mCallBackDeleteCount++;</span><br><span class="line">    LogUtil.debug(<span class="string">&quot;mDeleteSuccessSize: &quot;</span> + mDeleteSuccessSize + <span class="string">&quot; | mDeleteFailSize: &quot;</span> + mDeleteFailSize</span><br><span class="line">            + <span class="string">&quot; | mDeleteSize =&quot;</span> + mDeleteSize);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; deleteResults.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deleteResults.get(i).getStatus() == <span class="number">0</span>) &#123;</span><br><span class="line">            mDeleteSuccessSize = mDeleteSuccessSize + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deleteResults.get(i).getStatus() == <span class="number">1</span>) &#123;</span><br><span class="line">            mDeleteFailSize = mDeleteFailSize + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LogUtil.debug(<span class="string">&quot;mDeleteSuccessSize: &quot;</span> + mDeleteSuccessSize + <span class="string">&quot; | mDeleteFailSize: &quot;</span> + mDeleteFailSize</span><br><span class="line">            + <span class="string">&quot; | mDeleteSize =&quot;</span> + mDeleteSize);</span><br><span class="line">    <span class="keyword">if</span> (mDeleteSuccessSize + mDeleteFailSize &gt;= mDeleteSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mIsPagePause) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isCollect) &#123;</span><br><span class="line">                <span class="comment">// 回调第一次将第一次删除相册的结果数量赋值，有可能删除的是收藏，也有可能是普通。不管是什么类型先累加起来。</span></span><br><span class="line">                mDeleteSuccessAll += mDeleteSuccessSize;</span><br><span class="line">                <span class="comment">// 如果是第二次那么进行提示。</span></span><br><span class="line">                <span class="keyword">if</span> (mCallBackDeleteCount == <span class="number">2</span>) &#123;</span><br><span class="line">                    HHToast.makeText(getContext(), mDeleteSuccessAll + getResources().getString(</span><br><span class="line">                            R.string.delete_success_toast_prompt)).show();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果选中的相册不满足，选中收藏并且选中数量大于一</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                HHToast.makeText(getContext(), mDeleteSuccessSize + getResources().getString(</span><br><span class="line">                        R.string.delete_success_toast_prompt)).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mAlbumListAdapter.setSelecting(<span class="literal">false</span>);</span><br><span class="line">        mNavibar.setBackVisible(View.VISIBLE);</span><br><span class="line">        mNavibar.setNavigationRightLVisible(View.INVISIBLE);</span><br><span class="line">        mNavibar.setNavigationRightRIcon(getResources()</span><br><span class="line">                .getDrawable(R.drawable.img_choose_selector));</span><br><span class="line">        mDeleteSize = <span class="number">0</span>;</span><br><span class="line">        mDeleteSuccessSize = <span class="number">0</span>;</span><br><span class="line">        mDeleteFailSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RecyclerAdapter天坑，有mData对象，但.size值为0的时候不加载RecyclerAdapter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AlbumListAdapter</span><span class="params">(Context context, List&lt;AlbumListBean&gt; mData)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mContext = context;</span><br><span class="line">    <span class="built_in">this</span>.mData = mData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Application调用多次onCreate方法会导致bindService时出现类型转换异常的错误需要获取当前app进程，让service在app进程中进行bind</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAppProcess</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">processName</span> <span class="operator">=</span> getRunningProcessName();</span><br><span class="line">    <span class="keyword">return</span> processName != <span class="literal">null</span> &amp;&amp; processName.equalsIgnoreCase(<span class="built_in">this</span>.getPackageName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getRunningProcessName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">processId</span> <span class="operator">=</span> android.os.Process.myPid();</span><br><span class="line">    <span class="type">ActivityManager</span> <span class="variable">manager</span> <span class="operator">=</span> (ActivityManager) getApplicationContext().getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">    <span class="keyword">for</span> (ActivityManager.RunningAppProcessInfo processInfo : manager.getRunningAppProcesses()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (processInfo.pid == processId) &#123;</span><br><span class="line">                <span class="keyword">return</span> processInfo.processName;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用AlarmManager</p>
<p>取消alarm使用AlarmManager.cancel()函数，传入参数是个PendingIntent实例。</p>
<p>该函数会将所有跟这个PendingIntent相同的Alarm全部取消，怎么判断两者是否相同，android使用的是intent.filterEquals()，具体就是判断两个PendingIntent的action、data、type、class和category是否完全相同。即便使用intent.putExtras(bundle)方法，两者的bundle不一样，也可以进行取消。</p>
<ul>
<li>开发过程中，使用AlarmManager时遇到了一个问题至今网上没有明确原因：<br>构造intent，设置定时广播闹钟，在时间到达后，广播接收到的bundle为空</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setMessageEndTrigger</span><span class="params">(MessageRecommend requireMessage)</span> &#123;</span><br><span class="line">    <span class="type">Intent</span> <span class="variable">startMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MESSAGE_START_ACTION);</span><br><span class="line">    <span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">    bundle.putSerializable(MESSAGE, requireMessage);</span><br><span class="line">    startMessage.putExtras(bundle);</span><br><span class="line">    <span class="type">PendingIntent</span> <span class="variable">intent</span> <span class="operator">=</span> PendingIntent.getBroadcast(mContext,</span><br><span class="line">            MESSAGE_WHAT, startMessage, PendingIntent.FLAG_CANCEL_CURRENT);</span><br><span class="line">    <span class="keyword">if</span> (requireMessage == <span class="literal">null</span>) &#123;</span><br><span class="line">        LogUtil.debug(TAG + <span class="string">&quot;TimingMessage end is cancel&quot;</span>);</span><br><span class="line">        mAlarmManager.cancel(intent);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> TimeParseUtil.parseLong(requireMessage.getEndTime());</span><br><span class="line">    mAlarmManager.setExact(AlarmManager.RTC_WAKEUP, endTime, intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkStartMessage</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">    <span class="comment">// rec是空的</span></span><br><span class="line">    <span class="type">MessageRecommend</span> <span class="variable">rec</span> <span class="operator">=</span> (MessageRecommend) intent.getExtras().get(MESSAGE);</span><br><span class="line">    <span class="keyword">if</span> (!mAreaManager.checkArea(rec.getProvinceName(), rec.getCityName())) &#123;</span><br><span class="line">        LogUtil.warning(TAG + <span class="string">&quot;the city is change&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!mAccountManager.getAccountId().equals(rec.getAccount())) &#123;</span><br><span class="line">        LogUtil.warning(TAG + <span class="string">&quot;the Account is change&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sendOperatorMessage(rec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一种解决：将bundle使用putExtra方法设置Key和Value，放弃putExtras方法直接put进bundle</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setMessageStartTrigger</span><span class="params">(MessageRecommend requireMessage)</span> &#123;</span><br><span class="line">    <span class="type">Intent</span> <span class="variable">startMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MESSAGE_START_ACTION);</span><br><span class="line">    <span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">    bundle.putSerializable(MESSAGE, requireMessage);</span><br><span class="line">    startMessage.putExtra(MESSAGE, bundle);</span><br><span class="line">    <span class="type">PendingIntent</span> <span class="variable">intent</span> <span class="operator">=</span> PendingIntent.getBroadcast(mContext,</span><br><span class="line">            MESSAGE_WHAT, startMessage, PendingIntent.FLAG_CANCEL_CURRENT);</span><br><span class="line">    <span class="keyword">if</span> (requireMessage == <span class="literal">null</span>) &#123;</span><br><span class="line">        LogUtil.debug(TAG + <span class="string">&quot;TimingMessage start is cancel&quot;</span>);</span><br><span class="line">        mAlarmManager.cancel(intent);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> TimeParseUtil.parseLong(requireMessage.getStartTime());</span><br><span class="line">    LogUtil.debug(TAG + <span class="string">&quot;TimingMessage start time&quot;</span> + startTime);</span><br><span class="line">    mAlarmManager.setExact(AlarmManager.RTC_WAKEUP, startTime, intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>广播接收时使用先去调用getBundleExtra方法获取bundle，在通过bundle的getSerializable方法获取对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkStartMessage</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        <span class="type">MessageRecommend</span> <span class="variable">rec</span> <span class="operator">=</span> (MessageRecommend) intent.</span><br><span class="line">                getBundleExtra(MESSAGE).getSerializable(MESSAGE);</span><br><span class="line">        <span class="keyword">if</span> (rec == <span class="literal">null</span>) &#123;</span><br><span class="line">            LogUtil.debug(TAG + <span class="string">&quot;start time Message is null &quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LogUtil.debug(TAG + <span class="string">&quot;start time Message: &quot;</span> + rec.toString());</span><br><span class="line"><span class="comment">//        if (!mAreaManager.checkArea(rec.getProvinceName(), rec.getCityName())) &#123;</span></span><br><span class="line"><span class="comment">//            LogUtil.warning(TAG + &quot;the city is change&quot;);</span></span><br><span class="line"><span class="comment">//            return;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">if</span> (!mAccountManager.getAccountId().equals(rec.getAccount())) &#123;</span><br><span class="line">            LogUtil.warning(TAG + <span class="string">&quot;the Account is change&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sendOperatorMessage(rec);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第二种解决：<br>可以把传递的参数都转成String传，对象也通过Json转成字符串来传，如果既传对象又传String，那么String依旧穿不过来。</li>
</ul>
<h2 id="android-sharedUserId-”android-uid-system”"><a href="#android-sharedUserId-”android-uid-system”" class="headerlink" title="android:sharedUserId&#x3D;”android.uid.system”"></a>android:sharedUserId&#x3D;”android.uid.system”</h2><p>通过SharedUserId,拥有同一个User id的多个APK可以配置成运行在同一个进程中。</p>
<p>那么把程序的UID配成android.uid.system，也就是要让程序运行在系统进程中，这样就有权限来修改系统时间了。</p>
<p>android:sharedUserId不只可以把apk放到系统进程中，也可以配置多个APK运行在一个进程中，这样可以共享数据。</p>
<p>若无法使用系统权限则有如下两种解决方法：</p>
<p>方法一：</p>
<ul>
<li><p>在应用程序的AndroidManifest.xml中的manifest节点中加入android:sharedUserId&#x3D;”android.uid.system”这个属性。</p>
</li>
<li><p>修改Android.mk文件，加入LOCAL_CERTIFICATE :&#x3D; platform这一行</p>
</li>
<li><p>使用mm命令来编译，生成的apk就有修改系统时间的权限了。</p>
</li>
</ul>
<p>方法二：</p>
<ul>
<li><p>加入android:sharedUserId&#x3D;”android.uid.system”这个属性。</p>
</li>
<li><p>使用IDE编译出未加签名的apk文件，但是这个apk文件是不能用的。</p>
</li>
<li><p>使用目标系统的platform密钥来重新给apk文件签名。首先找到密钥文件，在我的Android源码目录中的位置是”build&#x2F;target&#x2F;product&#x2F;security”，下面的platform.pk8和platform.x509.pem两个文件。然后用Android提供的Signapk工具来签名，signapk的源代码是在”build&#x2F;tools&#x2F;signapk”下，用法为”signapk platform.x509.pem platform.pk8 input.apk output.apk”，文件名最好使用绝对路径防止找不到，也可以修改源代码直接使用。</p>
</li>
</ul>
<p>但项目中加上这条配置可能会导致无法运行：</p>
<p>原因是将加上这条配置的APP进行编译，导致编译后的应用签名和系统签名不一致。</p>
<p>程序想要运行在系统进程中还要有目标系统的platform key，就是上面的方法二提到的platform.pk8和platform.x509.pem两个文件。用这两个key签名后apk才真正可以放入系统进程中。第一个方法中加入LOCAL_CERTIFICATE :&#x3D; platform其实就是用这两个key来签名。</p>
<h1 id="项目经验总结"><a href="#项目经验总结" class="headerlink" title="项目经验总结"></a>项目经验总结</h1><ul>
<li>mediaPlayer中的setLooping(true) 可以在播放音乐中调用，也可以通过Service接口如果监听成功调用，传递当前音乐播放状态的方法中全局赋值通过mediaPlayer.setLooping(true)</li>
<li>在音乐播放中，使用SeekBar控件开启线程通过Handler向Activity更新进度条，切记一首歌曲播放完成后停掉线程</li>
<li>在使用switch中切记要写break；否则执行完case1还会执行case2</li>
<li>焦点问题，第一次点击如果没有触发监听，考虑是不是其他监听控件操作设置了焦点</li>
<li>第一次点击切换歌曲出现再次播放同样歌曲的情况，考虑在MusicService中的切换歌曲方法的position++ 或position– 变为–position，++position先赋值再操作</li>
<li>Notification中多次点击前台服务，android的back键需要点击多次。考虑每次点击前台服务都会入栈很多次，back出栈很多次，使用Activity的启动模式SingleTop，在mainfeast.xml设置任意Activity该Activity总是会在栈顶</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.Activity.PlayingMusicActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">&quot;singleTop&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>PendingIntent nIntent &#x3D; PendingIntent.getBroadcast(context,requestcode, pIntent, PendingIntent.FLAG_UPDATE_CURRENT);<br>主要用来推送服务<br>第一个参数，上下文；<br>第二个参数，需求码，来标记不同的意图<br>第三个参数，意图，包含着要传递的消息体<br>第四个参数，有四种，常用的两种：FLAG_CANCEL_CURRENT和FLAG_UPDATE_CURRENT<br>FLAG_CANCEL_CURRENT，有个cancel，说明如果使用同一个requestcode的两条pendingintent，只有最新发送的有效<br>FLAG_UPDATE_CURRENT，如果requestcode一样，之前的消息体会被最新的覆盖掉</li>
<li>Message.obtain()方式相比于直接new对象更高效，通过obtain方法获取Message对象使得Message到了重复的利用，减少了每次获取Message时去申请空间的时间。同时，这样也不会永无止境的去创建新对象，减小了Jvm垃圾回收的压力，提高了效率</li>
<li>如果将context作为参数传入handler会造成内存泄露问题，因为有可能这个context已经要onDestory了但handler还持有这个实例</li>
</ul>
<p>问题1：</p>
<p>Can’t create handler inside thread that has not called Looper.prepare()</p>
<p>解决：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Looper.prepare()；</span><br></pre></td></tr></table></figure>

<p>问题2：</p>
<p>getMainLooper()’ on a null object reference</p>
<p>解决：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Looper.getMainLooper()</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> android.view.MotionEvent.ACTION_CANCEL;<span class="comment">// 划出屏幕之外</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> android.view.MotionEvent.ACTION_DOWN;<span class="comment">// 屏幕摁下</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> android.view.MotionEvent.ACTION_MOVE;<span class="comment">// 屏幕移动</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> android.view.MotionEvent.ACTION_UP;<span class="comment">// 屏幕抬起</span></span><br></pre></td></tr></table></figure>

<h2 id="Android9以后使用Notification必须要设置channelID"><a href="#Android9以后使用Notification必须要设置channelID" class="headerlink" title="Android9以后使用Notification必须要设置channelID"></a>Android9以后使用Notification必须要设置channelID</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NotificationChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NotificationChannel</span>(<span class="string">&quot;001&quot;</span>, <span class="string">&quot;default&quot;</span>, NotificationManager.IMPORTANCE_DEFAULT);</span><br><span class="line">channel.enableLights(<span class="literal">true</span>);</span><br><span class="line">channel.setLightColor(Color.GREEN);</span><br><span class="line">channel.setShowBadge(<span class="literal">true</span>);</span><br><span class="line">channel.setLockscreenVisibility(Notification.VISIBILITY_SECRET);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取NotificationManager实例</span></span><br><span class="line">mNotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">mNotificationManager.createNotificationChannel(channel);</span><br><span class="line"><span class="comment">// 开启前台服务</span></span><br><span class="line">        <span class="keyword">if</span> (mMediaPlayer.isPlaying()) &#123;</span><br><span class="line">            startForeground(NOTIFICATION_ID, mNotification);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F; 使用前台服务还要加上权限</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- android 9.0上使用前台服务，需要添加权限 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.FOREGROUND_SERVICE&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="项目如何使用回调"><a href="#项目如何使用回调" class="headerlink" title="项目如何使用回调"></a>项目如何使用回调</h2><p>“只有我们才知道做些什么，但是我们并不清楚什么时候去做这些，只有其它模块才知道，因此我们必须把我们知道的封装成回调函数告诉其它模块”，异步回调最本质上就是事件驱动编程。</p>
<p>回调函数（callback）是什么？ - 码农的荒岛求生的回答 - 知乎 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19801131/answer/1641403537">https://www.zhihu.com/question/19801131/answer/1641403537</a></p>
<p>拿音乐举例子：先写一个回调接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MusicCallback</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">getMusic</span><span class="params">(Music music)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Service中的Binder类写一个注册回调，和接触回调的方法参数为定义的接口，并定义一个回调接口泛型的集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;MusicCallback&gt; mMusicCallbackList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerMusicCallback</span><span class="params">(MusicCallback musicCallback)</span> &#123;</span><br><span class="line"></span><br><span class="line">    mMusicCallbackList.add(musicCallback);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unregisterMusicCallback</span><span class="params">(MusicCallback musicCallback)</span> &#123;</span><br><span class="line"></span><br><span class="line">    mMusicCallbackList.remove(musicCallback);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在每次播放音乐时调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playMusic</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fileName = path;</span><br><span class="line">        mMediaPlayer.reset();</span><br><span class="line">        mMediaPlayer.setVolume(<span class="number">0.8f</span>, <span class="number">0.8f</span>);</span><br><span class="line">        mMediaPlayer.setDataSource(path);</span><br><span class="line">        mMediaPlayer.prepare();</span><br><span class="line">        mMediaPlayer.start();</span><br><span class="line">        updateSeekBar(path);</span><br><span class="line">        updateNotification();</span><br><span class="line">        <span class="keyword">for</span> (MusicCallback musicCallback : mMusicCallbackList) &#123;</span><br><span class="line">            <span class="comment">// 每次有音乐播放时，将该音乐传递给Service</span></span><br><span class="line">            musicCallback.getMusic(mMusic);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过服务对象注册接口，参数是定义的Callback</span></span><br><span class="line">mMusicServiceStub.registerMusicCallback(<span class="keyword">new</span> <span class="title class_">MusicCallback</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMusic</span><span class="params">(Music music)</span> &#123;</span><br><span class="line">        <span class="comment">// 参数即为当前正在播放的音乐，创建消息体通过handler更新UI</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">        message.what = <span class="number">1</span>;</span><br><span class="line">        handler.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Handler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.what == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 更新UI</span></span><br><span class="line">            update(music);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="AIDL使用RemoteCallBackList"><a href="#AIDL使用RemoteCallBackList" class="headerlink" title="AIDL使用RemoteCallBackList"></a>AIDL使用RemoteCallBackList</h3><p>client：</p>
<ul>
<li>新建IPersonListener.aidl文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.aidl.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.aidl.client.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IPersonListener</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">onDemandReceiver</span><span class="params">(in Person msg)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ManagerAIDL:新增两个回调方法，参数均为上述aidl文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">registerListener</span><span class="params">(IPersonListener listener)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">unregisterListener</span><span class="params">(IPersonListener listener)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>在Activity监听并注册。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">ServiceConnection</span> <span class="variable">mServiceConnection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceConnection</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> &#123;</span><br><span class="line">        mPersonManager = PersonManager.Stub.asInterface(service);</span><br><span class="line">        IPersonListener.<span class="type">Stub</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IPersonListener</span>.Stub() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDemandReceiver</span><span class="params">(Person msg)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">                <span class="comment">// 方法运行在Binder线程池中，是非ui线程，需要使用runOnUiThread，在UI主线程中更新UI。</span></span><br><span class="line">                runOnUiThread(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                        tvPerson.append(msg.toString());</span><br><span class="line">                        Log.d(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;onServiceConnected: &quot;</span> + msg.toString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mPersonManager.registerListener(listener);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>service：</p>
<ul>
<li>ManagerStub:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> RemoteCallbackList&lt;IPersonListener&gt; demandList = <span class="keyword">new</span> <span class="title class_">RemoteCallbackList</span>&lt;&gt;();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerListener</span><span class="params">(IPersonListener listener)</span> &#123;</span><br><span class="line">    Log.d(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;registerListener: &quot;</span>);</span><br><span class="line">    demandList.register(listener);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unregisterListener</span><span class="params">(IPersonListener listener)</span> &#123;</span><br><span class="line">    demandList.unregister(listener);</span><br><span class="line">    System.out.println(<span class="string">&quot;回调关闭&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (demandList != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nums</span> <span class="operator">=</span> demandList.beginBroadcast();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums; i++) &#123;</span><br><span class="line">                    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">                    person.setPrice(i);</span><br><span class="line">                    person.setName(<span class="string">&quot;SESE&quot;</span>);</span><br><span class="line">                    Log.d(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;run: &quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        demandList.getBroadcastItem(i).onDemandReceiver(person);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                demandList.finishBroadcast();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="死亡代理"><a href="#死亡代理" class="headerlink" title="死亡代理"></a>死亡代理</h3><p>​    Binder运行在服务端进程，如果服务端进程由于某种原因被异常终止，这个时候我们到服务端的Binder连接断裂（称之为Binder死亡），会导致我们的远程调用失败。更为关键的是，如果我们不知道Binder连接已经断裂，那么客户端的功能就会收到影响。为了解决这个问题，Binder中提供了两个配对的方法linkToDeath和unlinkToDeath，通过linkToDeath我们可以为Binder设置一个死亡代理，当Binder死亡时，我们会收到通知，这个时候我们就可以重新发起连接请求从而恢复连接。</p>
<p>​    为Binder设置死亡代理的方法：首先声明一个DeathRecipient对象。DeathRecipient是一个接口，其内部只有一个方法binderDied，我们需要实现这个方法，当Binder死亡的时候，系统就会回调binderDied方法，然后我们就可以移除之前绑定的binder代理并重新绑定远程服务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> IBinder.<span class="type">DeathRecipient</span> <span class="variable">mDeathRecipient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IBinder</span>.DeathRecipient() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// Binder死亡的时候，系统回调binderDied方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">binderDied</span><span class="params">()</span> &#123;</span><br><span class="line">        LogUtil.debug(<span class="string">&quot;BtMusicService  binderDied&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (mBtMusicManager != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Clear status</span></span><br><span class="line">            <span class="comment">// 解除死亡代理</span></span><br><span class="line">            mBtMusicManager.asBinder().unlinkToDeath(mDeathRecipient, <span class="number">0</span>);</span><br><span class="line">            mBtMusicManager = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Re-bind service</span></span><br><span class="line">        LogUtil.debug(<span class="string">&quot;Re-bind, when app exception exit.&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里重新绑定远程Service</span></span><br><span class="line">        bindService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">        <span class="comment">// 在ServiceConnection的onServiceConnected实现方法中重新获取死亡代理</span></span><br><span class="line">        <span class="comment">// 重新获取binder实例</span></span><br><span class="line">        mBtMusicManager = IBtMusicManager.Stub.asInterface(iBinder);</span><br><span class="line">        <span class="comment">// 重新设置死亡代理</span></span><br><span class="line">        iBinder.linkToDeath(mDeathRecipient, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>ubantu不能同时开启两个虚拟机，执行命令即可，sudo rmmod kvm_intel kvm</li>
</ul>
<h2 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH:= <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line"><span class="comment"># 给自己编译的模块名起一个名字</span></span><br><span class="line">LOCAL_PACKAGE_NAME := BtPhoneService</span><br><span class="line">LOCAL_PROGUARD_FLAG_FILES := proguard.flags</span><br><span class="line">LOCAL_PROGUARD_ENABLED := disabled</span><br><span class="line"><span class="comment"># androidAPP都会写的一句话用来参与编译相关内容</span></span><br><span class="line">LOCAL_MODULE_TAGS := optional</span><br><span class="line"><span class="comment"># 给APK一个签名</span></span><br><span class="line">LOCAL_CERTIFICATE := platform</span><br><span class="line"><span class="comment">#LOCAL_PROPRIETARY_MODULE := true</span></span><br><span class="line">LOCAL_MODULE_OWNER := ts</span><br><span class="line"><span class="comment">#LOCAL_JACK_ENABLED := disabled</span></span><br><span class="line"><span class="comment"># 用来制定哪些文件参与编译，必须是src下的 := +=在原来基础之上追加一些内容，call可以理解为查找的意思</span></span><br><span class="line">LOCAL_SRC_FILES := <span class="variable">$(<span class="built_in">call</span> all-java-files-under, java)</span></span><br><span class="line"><span class="comment"># 用来编译目录下res下的文件</span></span><br><span class="line">LOCAL_RESOURCE_DIR := <span class="variable">$(LOCAL_PATH)</span>/res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模块不想让你看，你直接用.jar文件就可以了</span></span><br><span class="line">LOCAL_STATIC_JAVA_LIBRARIES := \</span><br><span class="line">    android-support-v7-recyclerview \</span><br><span class="line">    android-support-v7-appcompat \</span><br><span class="line">    android-support-v4 \</span><br><span class="line">    btphonelib.static</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译外部模块，从外部加载进来，动态加载，不用将该jar包放到我的目录下</span></span><br><span class="line"><span class="comment"># 使用mm编译的话是不会找到这个模块的，使用mma编译的话就会先编译ts_framework在编译自身模块</span></span><br><span class="line">LOCAL_JAVA_LIBRARIES := \</span><br><span class="line">    ts-framework</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> vendor/ts/proprietary/common/Features/general-package-app-module.mk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预编译相关的内容，为编译其他内容所准备</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line"><span class="comment"># 预编译格式:=模块名:具体内容，jar包位置</span></span><br><span class="line">LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES := ts_btphone:libs/ts_btphone_sdk.jar \</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_MULTI_PREBUILT)</span></span><br><span class="line">使用adb push xxx.apk /vender/app/xx目录=模块名</span><br></pre></td></tr></table></figure>

<h2 id="使用接口解耦"><a href="#使用接口解耦" class="headerlink" title="使用接口解耦"></a>使用接口解耦</h2><p>项目中我们通常会发现在一个类中干了好多的事情,比如在service中不仅进行了业务逻辑，还进行了协议发送，如何解耦使得service只进行service操作，逻辑在一个类里操作，而协议在一个类里操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Excuter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">excutable</span><span class="params">(String funcId)</span>;</span><br><span class="line"></span><br><span class="line">    ResultBean <span class="title function_">excute</span><span class="params">(String funcId, String params)</span>;</span><br><span class="line">    <span class="comment">// 回调注册</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 回调销毁</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建SystemSetting实现Excuter接口只进行业务逻辑操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemSetting</span> <span class="keyword">implements</span> <span class="title class_">Excuter</span> &#123;</span><br><span class="line">    RemoteSettingManager mRemoteSettingManager;</span><br><span class="line">    GwRequestManager gwRequestManager;</span><br><span class="line">    Context mContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3在service中获取当前实例，并将当前实例作为参数调用协议manager中的add方法将实现Exuter的实例，add进Exuter的list里</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SystemSetting</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        mRemoteSettingManager = RemoteSettingManager.getInstance(context);</span><br><span class="line">        gwRequestManager = GwRequestManager.getInstance();</span><br><span class="line">        mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">excutable</span><span class="params">(String funcId)</span> &#123;</span><br><span class="line">        <span class="comment">// 这个funcID是否存在</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ResultBean <span class="title function_">excute</span><span class="params">(String funcId, String params)</span> &#123;</span><br><span class="line">        <span class="type">ResultBean</span> <span class="variable">resultBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResultBean</span>();</span><br><span class="line">        <span class="keyword">switch</span> (funcId) &#123;</span><br><span class="line">            <span class="keyword">case</span> REQ_MUTE_TYPE_SET:</span><br><span class="line">                resultBean = setMuteStatus(params);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> REQ_MUTE_TYPE_GET:</span><br><span class="line">                resultBean = getMuteStatus();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> REQ_MEDIA_VOLUME_SET:</span><br><span class="line">                resultBean = setMediaVolume(params);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> REQ_MEDIA_VOLUME_GET:</span><br><span class="line">                resultBean = getMediaVolume();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> REQ_EQUALIZER_SET:</span><br><span class="line">                resultBean = setEqualizerMode(params);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> REQ_EQUALIZER_GET:</span><br><span class="line">                resultBean = getEqualizerMode();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> REQ_CUS_EQUALIZER_SET:</span><br><span class="line">                resultBean = setCusEqualizer(params);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> REQ_CUS_EQUALIZER_GET:</span><br><span class="line">                resultBean = getCusEqualizer();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                LogUtil.warning(<span class="string">&quot;FUNCTION_ID&quot;</span> + funcId);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        resultBean.setFuncId(funcId);</span><br><span class="line">        <span class="keyword">return</span> resultBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mISoundCallback是系统音乐设置各种操作的回调</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        mRemoteSettingManager.registSoundCallback(mISoundCallback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">        mRemoteSettingManager.unregistSoundCallback(mISoundCallback);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>创建Manager只进行协议发送操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GwRequestManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;GwSettingServices&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">GwRequestManager</span> <span class="variable">sInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 1在service中获取当前实例，并调用init进行初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GwRequestManager <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SoundManager.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    sInstance = <span class="keyword">new</span> <span class="title class_">GwRequestManager</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2调用init进行初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        receiveRequest(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">receiveRequest</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        OpenGatewayManager.getInstance(context)</span><br><span class="line">                .registService(SERVICE_NAME, NODE_NAME, <span class="keyword">new</span> <span class="title class_">ServiceCallback</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onRequest</span><span class="params">(String requestId, String requestBody)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">                        <span class="built_in">super</span>.onRequest(requestId, requestBody);</span><br><span class="line">                        <span class="type">RequestBean</span> <span class="variable">requestBean</span> <span class="operator">=</span> ParseUtil.fromJson(requestBody, RequestBean.class);</span><br><span class="line">                        LogUtil.debug(TAG + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;requestBean:&quot;</span> + requestBean + <span class="string">&quot;requestBody:&quot;</span> + requestBody);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">funcId</span> <span class="operator">=</span> requestBean.getFuncId();</span><br><span class="line">                        remoteControl(funcId, requestBean.getParams(), requestId);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubscribe</span><span class="params">(String eventName, String subscribeBody)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">                        <span class="built_in">super</span>.onSubscribe(eventName, subscribeBody);</span><br><span class="line">                        Log.d(TAG, <span class="string">&quot;onSubscribe: &quot;</span> + eventName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Excuter&gt; excuters = Collections.synchronizedSet(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addExucter</span><span class="params">(Excuter excuter)</span> &#123;</span><br><span class="line">        excuters.add(excuter);</span><br><span class="line">        excuter.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeExucter</span><span class="params">(Excuter excuter)</span> &#123;</span><br><span class="line">        excuter.end();</span><br><span class="line">        excuters.remove(excuter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remoteControl</span><span class="params">(String funcId, String params, String requestId)</span> &#123;</span><br><span class="line">        LogUtil.debug(TAG + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;funcId:&quot;</span> + funcId + <span class="string">&quot;params:&quot;</span> + params + <span class="string">&quot;requestId:&quot;</span> + requestId);</span><br><span class="line">        <span class="type">ResultBean</span> <span class="variable">resultBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResultBean</span>();</span><br><span class="line">        resultBean.setFuncId(funcId);</span><br><span class="line">        <span class="keyword">for</span> (Excuter excuter : excuters) &#123;</span><br><span class="line">            <span class="comment">// 4遍历全局变量，判断当前协议的funcId是否属于规定funcId</span></span><br><span class="line">            <span class="keyword">if</span> (excuter.excutable(funcId)) &#123;</span><br><span class="line">                <span class="comment">// 5进行逻辑操作</span></span><br><span class="line">                resultBean = excuter.excute(funcId, params);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sendResponse(resultBean, requestId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendResponse</span><span class="params">(ResultBean result, String requestId )</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> ParseUtil.toJson(<span class="keyword">new</span> <span class="title class_">ResponseBean</span>(result.getCode(),</span><br><span class="line">                result.getMsg(), result.getFuncId(), result.getResult()));</span><br><span class="line">        <span class="comment">// mContext未定义若使用全局context，必须保证该context非activity避免内存泄露</span></span><br><span class="line">        OpenGatewayManager.getInstance(mContext).response(requestId, data);</span><br><span class="line">        LogUtil.debug(TAG + <span class="string">&quot;&quot;</span> + data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendNotify</span><span class="params">(String funcId, String data)</span> &#123;</span><br><span class="line">        OpenGatewayManager.getInstance(mContext).notify(EVT_MUTE_STATUS, data);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>service的onCreate方法操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GwRequestManager.getInstance().init(getApplicationContext());</span><br><span class="line"><span class="type">SystemSetting</span> <span class="variable">systemSetting</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SystemSetting</span>(getApplicationContext());</span><br><span class="line">GwRequestManager.getInstance().addExucter(systemSetting);</span><br></pre></td></tr></table></figure>

<h2 id="OKHTTP的构建实例拦截器问题"><a href="#OKHTTP的构建实例拦截器问题" class="headerlink" title="OKHTTP的构建实例拦截器问题"></a>OKHTTP的构建实例拦截器问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> OkHttpClient <span class="title function_">getOkClient</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">HttpLoggingInterceptor</span> <span class="variable">loggingInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpLoggingInterceptor</span>(<span class="keyword">new</span> <span class="title class_">HttpLoggingInterceptor</span>.Logger() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">// 记录每次请求的log</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span> &#123;</span><br><span class="line">            LogUtil.debug(<span class="string">&quot;message =&quot;</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    loggingInterceptor.setLevel(HttpLoggingInterceptor.Level.HEADERS);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder()</span><br><span class="line">            <span class="comment">// 返回的okhttp client 请求有可能被重定向时使用addNetworkInterceptor,可使拦截器记录多次，而Application Interceptors只会记录一次</span></span><br><span class="line">            .addNetworkInterceptor(loggingInterceptor)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用java解压缩"><a href="#使用java解压缩" class="headerlink" title="使用java解压缩"></a>使用java解压缩</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unZip</span><span class="params">(File srcFile, String destDirPath)</span> <span class="keyword">throws</span> RuntimeException &#123;</span><br><span class="line">    <span class="comment">// 判断源文件是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (!srcFile.exists()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开始解压</span></span><br><span class="line">    <span class="type">ZipFile</span> <span class="variable">zipFile</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        zipFile = <span class="keyword">new</span> <span class="title class_">ZipFile</span>(srcFile);</span><br><span class="line">        Enumeration&lt;?&gt; entries = zipFile.entries();</span><br><span class="line">        <span class="keyword">while</span> (entries.hasMoreElements()) &#123;</span><br><span class="line">            <span class="type">ZipEntry</span> <span class="variable">entry</span> <span class="operator">=</span> (ZipEntry) entries.nextElement();</span><br><span class="line">            LogUtil.debug(TAG + <span class="string">&quot;unzip&quot;</span> + entry.getName());</span><br><span class="line">            <span class="comment">// 如果是文件夹，就创建个文件夹</span></span><br><span class="line">            <span class="keyword">if</span> (entry.isDirectory()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">dirPath</span> <span class="operator">=</span> destDirPath + <span class="string">&quot;/&quot;</span> + entry.getName();</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">File</span>(dirPath).mkdir();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是文件，就先创建一个文件，然后用io流把内容copy过去</span></span><br><span class="line">                <span class="type">File</span> <span class="variable">targetFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(destDirPath + <span class="string">&quot;/&quot;</span> + entry.getName());</span><br><span class="line">                targetFile.createNewFile();</span><br><span class="line">                <span class="comment">// 将压缩文件内容写入到这个文件中</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> zipFile.getInputStream(entry);</span><br><span class="line">                <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(targetFile);</span><br><span class="line">                <span class="type">int</span> len;</span><br><span class="line">                <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[BUFFER_SIZE];</span><br><span class="line">                <span class="keyword">while</span> ((len = is.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    fos.write(buf, <span class="number">0</span>, len);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 关流顺序，先打开的后关闭</span></span><br><span class="line">                fos.close();</span><br><span class="line">                is.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;unzip error from ZipUtils&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (zipFile != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                zipFile.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在使用AIDL创建实体时，如何使用自定义类型，和自定义类型集合"><a href="#在使用AIDL创建实体时，如何使用自定义类型，和自定义类型集合" class="headerlink" title="在使用AIDL创建实体时，如何使用自定义类型，和自定义类型集合"></a>在使用AIDL创建实体时，如何使用自定义类型，和自定义类型集合</h2><p>例子：</p>
<p>提示，集合中的类型也必须实现Parcelable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> NaviPoiBase poi;</span><br><span class="line"><span class="keyword">private</span> List&lt;NaviPoiBase&gt; childPois;</span><br><span class="line"><span class="keyword">private</span> List&lt;Position&gt; poiPolygonBounds;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">NaviPoi</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">NaviPoi</span><span class="params">(Parcel in)</span> &#123;</span><br><span class="line">    poi = in.readParcelable(NaviPoiBase.class.getClassLoader());</span><br><span class="line">    childPois = in.createTypedArrayList(NaviPoiBase.CREATOR);</span><br><span class="line">    poiPolygonBounds = in.createTypedArrayList(Position.CREATOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeToParcel</span><span class="params">(Parcel dest, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    dest.writeParcelable(poi, flags);</span><br><span class="line">    dest.writeTypedList(childPois);</span><br><span class="line">    dest.writeTypedList(poiPolygonBounds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="项目中如何在启动时开启adb"><a href="#项目中如何在启动时开启adb" class="headerlink" title="项目中如何在启动时开启adb"></a>项目中如何在启动时开启adb</h2><p>项目启动时会加载init.rc</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Always start adbd on userdebug and eng builds</span><br><span class="line">on property:ro.debuggable=<span class="number">1</span></span><br><span class="line">    write /sys/class/android_usb/android0/enable <span class="number">1</span></span><br><span class="line">    <span class="meta"># start adbd</span></span><br><span class="line"></span><br><span class="line"># Restart adbd so it can run as root</span><br><span class="line">on property:service.adb.root=<span class="number">1</span></span><br><span class="line">    write /sys/class/android_usb/android0/enable <span class="number">0</span></span><br><span class="line">    <span class="meta"># restart adbd</span></span><br><span class="line">    write /sys/class/android_usb/android0/enable <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>可以看到start adbd 和 restart adbd 都被注释掉了，所以启动时没有adb设备</p>
<p>取消注释即可。</p>
<h2 id="android10以上无法在设备上创建文件夹"><a href="#android10以上无法在设备上创建文件夹" class="headerlink" title="android10以上无法在设备上创建文件夹"></a>android10以上无法在设备上创建文件夹</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在<span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">&lt;/<span class="attr">application</span>&gt;</span></span><br><span class="line">中加上这句，配置存储权限</span><br><span class="line">android:requestLegacyExternalStorage=&quot;true&quot;</span><br></pre></td></tr></table></figure>

<p><strong>使用Gradle无法下载</strong></p>
<p>在工程Gradle配置google()和镜像</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        maven &#123; url &#x27;http://maven.aliyun.com/nexus/content/groups/public/&#x27; &#125;</span><br><span class="line">        maven &#123; url &#x27;http://maven.aliyun.com/nexus/content/repositories/jcenter&#x27; &#125;</span><br><span class="line">        maven &#123; url &#x27;http://maven.aliyun.com/nexus/content/repositories/google&#x27; &#125;</span><br><span class="line">        maven &#123; url &#x27;http://maven.aliyun.com/nexus/content/repositories/gradle-plugin&#x27; &#125;</span><br><span class="line">        maven&#123;</span><br><span class="line">            url &#x27;http://maven.google.com&#x27;</span><br><span class="line">            name &#x27;Google&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &#x27;com.android.tools.build:gradle:3.4.2&#x27;</span><br><span class="line"></span><br><span class="line">        // NOTE: Do not place your application dependencies here; they belong</span><br><span class="line">        // in the individual module build.gradle files</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        maven&#123;url &#x27;http://maven.aliyun.com/nexus/content/groups/public/&#x27; &#125;</span><br><span class="line">        maven&#123;</span><br><span class="line">            url &#x27;http://maven.google.com&#x27;</span><br><span class="line">            name &#x27;Google&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task clean(type: Delete) &#123;</span><br><span class="line">    delete rootProject.buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他项目集成aar包出现无法访问方法的情况"><a href="#其他项目集成aar包出现无法访问方法的情况" class="headerlink" title="其他项目集成aar包出现无法访问方法的情况"></a>其他项目集成aar包出现无法访问方法的情况</h2><ul>
<li>可以查看这个集成的aar包是否已经成为系统的动态jar包，所有项目尽管集成aar包，也需要首先访问系统的同名aar包。</li>
</ul>
<p>解决方法：将自己的包替换系统引用工程的aar包，编译后即可找到方法</p>
<h2 id="想使用Get方法在URL上发送JSON"><a href="#想使用Get方法在URL上发送JSON" class="headerlink" title="想使用Get方法在URL上发送JSON"></a>想使用Get方法在URL上发送JSON</h2><p>可以使用URLEncoder.encode进行转义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NLog.i(TAG, <span class="string">&quot;Method: &quot;</span> + data.getMethod());</span><br><span class="line"><span class="type">String</span> <span class="variable">params</span> <span class="operator">=</span> <span class="string">&quot;Method=&quot;</span> + data.getMethod() + <span class="string">&quot;&amp;RequestId=&quot;</span> + data.getRequestId() + <span class="string">&quot;&amp;EventName=&quot;</span> + data.getEventName() + <span class="string">&quot;&amp;ChannelId=&quot;</span> + data.getChannelId() + <span class="string">&quot;&amp;Body=&#123;&#125;&quot;</span>;</span><br><span class="line">uri = <span class="string">&quot;http://&quot;</span> + host + <span class="string">&quot;:&quot;</span> + port + path + <span class="string">&quot;?&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    uri += URLEncoder.encode(params, <span class="string">&quot;UTF8&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">NLog.i(TAG, <span class="string">&quot;uri: &quot;</span> + uri);</span><br></pre></td></tr></table></figure>

<h2 id="使用Glide将String图片地址显示到控件中"><a href="#使用Glide将String图片地址显示到控件中" class="headerlink" title="使用Glide将String图片地址显示到控件中"></a>使用Glide将String图片地址显示到控件中</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(mAlbumImageView).asDrawable().load(info.getpCoverArtURI()).into(mAlbumImageView);</span><br></pre></td></tr></table></figure>

<h2 id="同一个进程获取单例后进行注册回调发现问题"><a href="#同一个进程获取单例后进行注册回调发现问题" class="headerlink" title="同一个进程获取单例后进行注册回调发现问题"></a>同一个进程获取单例后进行注册回调发现问题</h2><p>比如我在写信号回调两个类同属一个进程获取实例后，调用registerListener进行注册发现这是单纯的赋值listener，那么这两个类不管谁注册第二个总会覆盖掉，所以导致第一个类的回调无法收到，改成将listener，add进list即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">registerListener</span><span class="params">(onNotifyListener listener)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mOnNotifyListener = listener;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遇到无法调用在framework中新加的方法，该怎么操作"><a href="#遇到无法调用在framework中新加的方法，该怎么操作" class="headerlink" title="遇到无法调用在framework中新加的方法，该怎么操作"></a>遇到无法调用在framework中新加的方法，该怎么操作</h2><p>因为framework在android中作为动态.jar包的存在，想调用framework中已经存在的方法或者是新加的方法需要在java包下，新建一个android包用于调用</p>
<p>例如如下格式：</p>
<p><img src="/typora-user-images/image-20220331104928251.png" alt="image-20220331104928251"></p>
<p>这个类里的内容如下：</p>
<p>只需要写需要调用方法的方法签名（不用写方法体，写方法名和参数），让编译器通过编译，运行时android系统会自动引用framework中的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> android.location;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocationManager</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendLocationChange</span><span class="params">(Bundle bundle)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestLocationUpdates</span><span class="params">(String provider, <span class="type">long</span> minTime, <span class="type">float</span> minDistance,</span></span><br><span class="line"><span class="params">                                       LocationListener listener)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="简单的获取定位demo"><a href="#简单的获取定位demo" class="headerlink" title="简单的获取定位demo"></a>简单的获取定位demo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">LocationManager locationManager;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(com.hht.microservice.R.layout.activity_main);</span><br><span class="line">    startService(<span class="keyword">new</span> <span class="title class_">Intent</span>(MainActivity.<span class="built_in">this</span>, MicroService.class));</span><br><span class="line">    <span class="comment">//        startService(new Intent(this, OpenGateWayService.class));</span></span><br><span class="line">    getSystemLocation();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getSystemLocation</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (locationManager == <span class="literal">null</span>) &#123;</span><br><span class="line">        locationManager = (LocationManager) <span class="built_in">this</span>.getSystemService(Context.LOCATION_SERVICE);</span><br><span class="line">        <span class="keyword">if</span> (ActivityCompat.checkSelfPermission(<span class="built_in">this</span>, Manifest</span><br><span class="line">                                               .permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED &amp;&amp; ActivityCompat</span><br><span class="line">            .checkSelfPermission(<span class="built_in">this</span>, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可使用GPS或者network获取位置，GPS比较准确，而network不准确。</span></span><br><span class="line">        locationManager.requestLocationUpdates(<span class="string">&quot;gps&quot;</span>, <span class="number">5000</span>, <span class="number">0</span>, locationListener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">LocationListener</span> <span class="variable">locationListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocationListener</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLocationChanged</span><span class="params">(Location location)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">latitude</span> <span class="operator">=</span> location.getLatitude();</span><br><span class="line">        <span class="type">double</span> <span class="variable">longitude</span> <span class="operator">=</span> location.getLongitude();</span><br><span class="line">        Log.d(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;onLocationChanged lat: &quot;</span> + latitude + <span class="string">&quot;lon: &quot;</span> + longitude);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStatusChanged</span><span class="params">(String provider, <span class="type">int</span> status, Bundle extras)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onProviderEnabled</span><span class="params">(String provider)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onProviderDisabled</span><span class="params">(String provider)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 主屏模拟定位</span></span><br><span class="line">mHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(Looper.getMainLooper()) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">eventName</span> <span class="operator">=</span> <span class="string">&quot;LocationChange&quot;</span>;</span><br><span class="line">        Map&lt;String, String&gt; result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        putMethod(result, eventName);</span><br><span class="line">        result.put(<span class="string">&quot;Data&quot;</span>, System.currentTimeMillis() / <span class="number">1000000.0</span> + <span class="string">&quot;,&quot;</span> + System.currentTimeMillis() / <span class="number">1000000.0</span>);</span><br><span class="line">        result.put(<span class="string">&quot;Timestamp&quot;</span>, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">        EventDispatcher.getInstance().publishEvent(eventName,</span><br><span class="line">                                                   <span class="keyword">new</span> <span class="title class_">TextWebSocketFrame</span>(JSON.toJSONString(result)));</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;-------------------&gt; onLocationChanged: &quot;</span> + eventName);</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;------------&gt; notify: &quot;</span> + JSON.toJSONString(result));</span><br><span class="line">        mHandler.sendEmptyMessageDelayed(<span class="number">0</span>, <span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">mHandler.sendEmptyMessage(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Gerrit报错"><a href="#Gerrit报错" class="headerlink" title="Gerrit报错"></a>Gerrit报错</h2><ul>
<li>当一笔代码已经入库，在带这这笔gerrit去编的时候就会报如下错误。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在cherry-pick的时候出现以下错误提示，是对同一提交重复做cherry-pick引起的。</span><br><span class="line"><span class="comment"># On branch***</span></span><br><span class="line"><span class="comment"># You are currentlycherry-picking.</span></span><br><span class="line"><span class="comment">#   (all conflicts fixed: run &quot;gitcommit&quot;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">nothing to commit,working directory clean</span><br><span class="line">The previouscherry-pick is now empty, possibly due to conflict resolution.</span><br><span class="line">If you wish to commitit anyway, use:</span><br><span class="line">    git commit --allow-empty</span><br><span class="line">Otherwise, please use<span class="string">&#x27;git reset&#x27;</span></span><br><span class="line"></span><br><span class="line">分析：没有冲突输出，提示如果要提交，需要做空提交，说明这次cherry-pick的内容可能已经在这个分支上提交过了。</span><br><span class="line">验证：1、查看这个哈希值所修改的文件  2、查看某个文件的修改<span class="built_in">log</span>     3、有相同的提交注释</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果赋值OK的情况下通过序列化后发现参数名不一致考虑是不是开启了混淆</p>
</li>
<li><p>如下这种错为gerrit服务器没有这种路径，尝试更改本地.gradle输出APK文件名</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">exec</span>]: <span class="built_in">cp</span> /home/iovadmin/.space_jenkins/workspace/FsemGestureService/FsemGestureService/app/build/outputs/apk/release/FsemGestureService.apk .</span><br><span class="line"><span class="built_in">cp</span>: cannot <span class="built_in">stat</span> <span class="string">&#x27;/home/iovadmin/.space_jenkins/workspace/FsemGestureService/FsemGestureService/app/build/outputs/apk/release/FsemGestureService.apk&#x27;</span>: No such file or directory</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">applicationVariants.all &#123; variant -&gt;</span><br><span class="line">    variant.outputs.all &#123; output -&gt;</span><br><span class="line">        <span class="type">def</span> <span class="variable">outputFile</span> <span class="operator">=</span> output.outputFile</span><br><span class="line">        def fileName</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(outputFile != <span class="literal">null</span> &amp;&amp; outputFile.name.endsWith(<span class="string">&#x27;.apk&#x27;</span>)</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (variant.buildType.name == <span class="string">&#x27;release&#x27;</span>) &#123;</span><br><span class="line">            -   fileName = <span class="string">&quot;GestureService.apk&quot;</span></span><br><span class="line">            +   fileName = <span class="string">&quot;FsemGestureService.apk&quot;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (variant.buildType.name == <span class="string">&#x27;debug&#x27;</span>) &#123;</span><br><span class="line">            -   fileName = <span class="string">&quot;GestureService_Debug.apk&quot;</span></span><br><span class="line">            +   fileName = <span class="string">&quot;FsemGestureService_Debug.apk&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            outputFileName = fileName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="微服务绑定问题"><a href="#微服务绑定问题" class="headerlink" title="微服务绑定问题"></a>微服务绑定问题</h2><p>若有两个微服务，A和B，一个项目同时用到了两个微服务。一些功能是在A发送，另一些是在B，如果A连接失败了B连接未失败，但连接A功能的初始化是在回调连接B里去做的，这样会导致B连接未失败就永远无法初始化需要A传输的功能。</p>
<p>分开进行判断连接成功的回调。</p>
<h2 id="repo-sync更新git仓库报错：已拒绝，会破坏现有的标签"><a href="#repo-sync更新git仓库报错：已拒绝，会破坏现有的标签" class="headerlink" title="repo sync更新git仓库报错：已拒绝，会破坏现有的标签"></a>repo sync更新git仓库报错：已拒绝，会破坏现有的标签</h2><p>碰到好几次这种情况，这个问题的原因是，上一次拉代码将一个远程的tag拉到了本地，随后远程的tag被更新了，这就导致远程的tag和我们本地的tag有冲突。</p>
<p>我的解决方式是，先删除本地的这个tag，以远程的为准。假设报错的tag是zqb_all_tag</p>
<p>即先</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo forall -c git tag -d zqb_all_tag</span><br></pre></td></tr></table></figure>

<p>再重新</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo <span class="built_in">sync</span></span><br></pre></td></tr></table></figure>

<h2 id="规范的HandlerThread写法"><a href="#规范的HandlerThread写法" class="headerlink" title="规范的HandlerThread写法"></a>规范的HandlerThread写法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Handler mOnFailedRetryHandler;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">HandlerThread</span> <span class="variable">mHandlerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerThread</span>(TAG);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        NLog.i(TAG, <span class="string">&quot;onCreate&quot;</span>);</span><br><span class="line">        ServiceManager.addService(<span class="string">&quot;com.hht.microservice&quot;</span>, microStub);</span><br><span class="line">        mHandlerThread.start();</span><br><span class="line">        mOnFailedRetryHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(mHandlerThread.getLooper());</span><br><span class="line">        mClient = <span class="keyword">new</span> <span class="title class_">HttpClient</span>(mOnFailedRetryHandler);</span><br><span class="line">        mClient.start(<span class="string">&quot;192.168.4.4&quot;</span>, <span class="number">9999</span>,  );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        NLog.i(TAG, <span class="string">&quot;onDestroy&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        mHandlerThread.quitSafely();</span><br><span class="line">        <span class="keyword">if</span> (mOnFailedRetryHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">            mOnFailedRetryHandler.removeCallbacksAndMessages(<span class="literal">null</span>);</span><br><span class="line">            mOnFailedRetryHandler = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用WindowManager"><a href="#使用WindowManager" class="headerlink" title="使用WindowManager"></a>使用WindowManager</h2><p>WindowManager相关参数参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wjr1949/article/details/71054975">https://blog.csdn.net/wjr1949/article/details/71054975</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 黑天白夜切换容易导致重复addView或者更新不存在的Layout，应该每次init的时候都remove掉Layout</span></span><br><span class="line"><span class="meta">@SuppressLint(&quot;ClickableViewAccessibility&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initChildLockManager</span><span class="params">()</span> &#123;</span><br><span class="line">    removeChildLockWindow();</span><br><span class="line">    mChildLockWindow = (WindowManager) <span class="built_in">this</span>.getSystemService(WINDOW_SERVICE);</span><br><span class="line">    <span class="type">LayoutInflater</span> <span class="variable">inflater</span> <span class="operator">=</span> LayoutInflater.from(<span class="built_in">this</span>);</span><br><span class="line">    mChildLockLayout = (RelativeLayout) inflater.inflate(R.layout.child_lock_layout, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (mChildLockStatus) &#123;</span><br><span class="line">        NLog.d(TAG, <span class="string">&quot;child lock is open&quot;</span>);</span><br><span class="line">        addChildLockView();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 已经addview的解决方法。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addChildLockView</span><span class="params">()</span> &#123;</span><br><span class="line">    removeChildLockWindow();</span><br><span class="line">    mChildLockWindow.addView(mChildLockLayout, getLayoutParams());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeChildLockWindow</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mChildLockLayout == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mChildLockLayout.getParent() != <span class="literal">null</span>) &#123;</span><br><span class="line">        mChildLockWindow.removeViewImmediate(mChildLockLayout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onChildLockModeChanged</span><span class="params">(<span class="type">boolean</span> mode)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mChildLockStatus = mode;</span><br><span class="line">    <span class="keyword">if</span> (mode) &#123;</span><br><span class="line">        mMaskManager.closeHiphiMask();</span><br><span class="line">        addChildLockView();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mChildLockWindow != <span class="literal">null</span>) &#123;</span><br><span class="line">            removeChildLockWindow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> WindowManager.LayoutParams <span class="title function_">getLayoutParams</span><span class="params">()</span> &#123;</span><br><span class="line">    WindowManager.<span class="type">LayoutParams</span> <span class="variable">lp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowManager</span>.LayoutParams(</span><br><span class="line">            ViewGroup.LayoutParams.MATCH_PARENT,</span><br><span class="line">            ViewGroup.LayoutParams.MATCH_PARENT,</span><br><span class="line">            WindowManager.LayoutParams.TYPE_APPLICATION,</span><br><span class="line">            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE</span><br><span class="line">                    | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL,</span><br><span class="line">            PixelFormat.TRANSLUCENT);</span><br><span class="line">    lp.setTitle(<span class="string">&quot;ChildLock&quot;</span>);</span><br><span class="line">    lp.windowAnimations = <span class="number">0</span>;</span><br><span class="line">    lp.gravity = Gravity.CENTER;</span><br><span class="line">    <span class="keyword">return</span> lp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用Glide加载图片</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(mAlbumImageView).asDrawable()<span class="comment">// 转为Drawable</span></span><br><span class="line">    .placeholder(mAlbumImageView.getDrawable())<span class="comment">// 切换图片的瞬间用于显示上一张图片，多次更新数据的时候避免闪烁问题，占位属性内部可以设置默认图片比如placeholder(R.mipmap.ic_launcher)</span></span><br><span class="line">    .load(info.getpCoverArtURI())<span class="comment">// 这里你可以指定哪个图片应该被加载，同上它会是一个   字符串的形式表示一个网络图片的 URL</span></span><br><span class="line">    .into(mAlbumImageView);<span class="comment">// 你的图片会显示到对应的 ImageView 中。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// touch事件中：</span></span><br><span class="line">    view.getParent().requestDisallowInterceptTouchEvent(<span class="literal">true</span>);  <span class="comment">// 告诉父view不要拦截此事件</span></span><br><span class="line">    view.getParent().requestDisallowInterceptTouchEvent(<span class="literal">false</span>);  <span class="comment">// 告诉父view可以拦截此事件</span></span><br></pre></td></tr></table></figure>

<p>用FragmentTransaction来控制fragment的hide和show时，那么这个方法就会被调用。每当你对某个Fragment使用hide或者是show的时候，那么这个Fragment就会自动调用这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onHiddenChanged</span><span class="params">(<span class="type">boolean</span> hidden)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onHiddenChanged(hidden);</span><br><span class="line">    NLog.i(TAG, <span class="string">&quot;onHiddenChanged hidden:&quot;</span> + hidden);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!hidden) &#123;<span class="comment">//重新显示到最前端中</span></span><br><span class="line">        sendNotify(Constants.ACTION_APP_LOAD_DATA, Constants.INVALID_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Gson序列化List</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;RequestSecondScreenActivity&gt; list = gson.fromJson(data, <span class="keyword">new</span> <span class="title class_">TypeToken</span>&lt;ArrayList&lt;RequestSecondScreenActivity&gt;&gt;() &#123;&#125;.getType());</span><br></pre></td></tr></table></figure>

<p>TextView增加一个小图标方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mShortcutPlayText.setCompoundDrawablesWithIntrinsicBounds(ResourcesCompat.getDrawable(getResources(), Utils.getResId(R.drawable.ui_ic_btn_shortcut_play_selector), <span class="literal">null</span>), <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Android-Studio报错：the-minSdk-version-should-not-be-declared-in-the-android-manifest-file-解决办法"><a href="#Android-Studio报错：the-minSdk-version-should-not-be-declared-in-the-android-manifest-file-解决办法" class="headerlink" title="Android Studio报错：the minSdk version should not be declared in the android manifest file 解决办法"></a>Android Studio报错：the minSdk version should not be declared in the android manifest file 解决办法</h2><p>删除AndroidManifest.xml中的</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-sdk</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:minSdkVersion</span>=<span class="string">&quot;24&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:targetSdkVersion</span>=<span class="string">&quot;27&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>BuildConfig.dex冲突：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: com.android.tools.r8.utils.b: Error: /home/tsdl/Fsem/fsemlauncher/app/build/intermediates/project_dex_archive/release/out/com/hht/launcher/BuildConfig.dex, Type com.hht.launcher.BuildConfig is defined multiple <span class="built_in">times</span>: /home/tsdl/Fsem/fsemlauncher/app/build/intermediates/project_dex_archive/release/out/com/hht/launcher/BuildConfig.dex, /home/tsdl/Fsem/fsemlauncher/MultiMediaLabrary/build/.transforms/fd72623b18dd208da5b9995f8a9f639a/classes/classes.dex</span><br></pre></td></tr></table></figure>

<p>解决方法：AndroidManifest.xml package名称冲突，改个名后面加个1</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.hht.launcher1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Android-在push-APK的时候发现总是起不来"><a href="#Android-在push-APK的时候发现总是起不来" class="headerlink" title="Android 在push APK的时候发现总是起不来"></a>Android 在push APK的时候发现总是起不来</h2><ul>
<li><p>调查是否有已存在的apk安装，uninstall一下</p>
</li>
<li><p>调查安装app目录下同级目录是否存在apk，或上一级目录存在apk</p>
</li>
</ul>
<h1 id="Android-Studio中XML文件属性不提示的解决办法！"><a href="#Android-Studio中XML文件属性不提示的解决办法！" class="headerlink" title="Android Studio中XML文件属性不提示的解决办法！"></a>Android Studio中XML文件属性不提示的解决办法！</h1><p>点击菜单file-project structure，将各个module的compile sdk version版本降低至29。</p>
<h1 id="repo-init-报错"><a href="#repo-init-报错" class="headerlink" title="repo init 报错"></a>repo init 报错</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/home/tsdl/.repo/repo/main.py&quot;, line 513, in &lt;module&gt;</span><br><span class="line">    _Main(sys.argv[1:])</span><br><span class="line">  File &quot;/home/tsdl/.repo/repo/main.py&quot;, line 478, in _Main</span><br><span class="line">    _CheckWrapperVersion(opt.wrapper_version, opt.wrapper_path)</span><br><span class="line">  File &quot;/home/tsdl/.repo/repo/main.py&quot;, line 209, in _CheckWrapperVersion</span><br><span class="line">    exp = Wrapper().VERSION</span><br><span class="line">  File &quot;/home/tsdl/.repo/repo/wrapper.py&quot;, line 29, in Wrapper</span><br><span class="line">    _wrapper_module = imp.load_source(&#x27;wrapper&#x27;, WrapperPath())</span><br><span class="line">IOError: [Errno 2] No such file or directory</span><br></pre></td></tr></table></figure>

<p>看一看自己的上层目录是否含有.repo文件，有则给他删了</p>
<p>Andorid查找差异命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pm dump com.seres.settings | grep version</span><br><span class="line">pm dump com.seres.publicadapter | grep version</span><br><span class="line">pm path com.seres.publicadapter</span><br></pre></td></tr></table></figure>

<p>将该包引入系统使用implementation</p>
<p>已经引入系统的包使用compileOnly编译通过即可</p>
<p>JAVA无论如何代码都会走到finally{}代码块中</p>
<h1 id="Android系统个人总结"><a href="#Android系统个人总结" class="headerlink" title="Android系统个人总结"></a>Android系统个人总结</h1><p>    请求Activity或Service启动首先会请求AMS，而AMS判断该进程是否存在，如果不存在的话就走AMS的startProcessLocked方法最后需要与Zygote创建socket连接，而Zygote会runSelectLoop无限循环等待是否有Socket的连接请求，如果有则拿到参数去fork一个进程，该进程会通过反射去拿到对应的ActivityThread的main方法，并且该main方法实在异常抛出的时候去执行的，异常是由ZygoteInit的main方法去捕获的，这种抛出异常的方式会清除所有的设置过程需要的堆栈帧，在ActivitThread的main方法中，还会创建主线程的H类，用于主线程内部的消息循环，执行完之后还需要调用binder的ProcessState::startThreadPool函数来启动线程池，还需要调用IPCThreadState::self()-&gt;joinThreadPool将当前线程注册到binder驱动程序中，这些都是在Zygote里完成的，而进程又是从Zygote孵化而来所以可以使用binder进行通信，而NativeService是init进程拉起来的需要手动执行binder线程池，并且手动注册binder驱动。</p>
<p>    在桌面上点击的所有APP都是Launcher请求AMS去启动该应用程序的。AMS会首先检查调用者权限，根据Intent的flag决定启动模式，最后通过binder的方式往ApplicationThread发，而ApplicationThread继承IApplicationThread.Stub，才会收到AMS的回调，ApplicationThread作为ActivityThread的内部类，因为ApplicationThread是一个Binder通信接口他在binder的线程池中不在主线程，所以要通过H的Handler消息到主线程，在主线程中启动Activity，创建Activity的上下文，通过类加载器去启动Activity，最后执行Activity的onCreate()方法。</p>
<p>例如在应用中启动一个Service</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startService()； <span class="comment">//或 binderService()</span></span><br></pre></td></tr></table></figure>

<p><img src="/typora-user-images/image-20250120230436844.png" alt="image-20250120230436844"></p>
<p>当App通过调用Android API方法startService（）或binderService（）来生成并启动服务的过程，主要是由ActivityManagerService来完成的。</p>
<ol>
<li>ActivityManagerService通过Socket通信方式向Zygote进程请求生成(fork)用于承载服务的进程ActivityThread。此处讲述启动远程服务的过程，即服务运行于单独的进程中，对于运行本地服务则不需要启动服务的过程。ActivityThread是应用程序的主线程；ActivityManagerService通过Socket通信方式向Zygote进程请求生成(fork)用于承载服务的进程ActivityThread。 此处讲述启动远程服务的过程，即服务运行于单独的进程中，对于运行本地服务则不需要启动服务的过程。 ActivityThread是应用程序的主线程；</li>
<li>Zygote通过fork的方法，将zygote进程复制生成新的进程，并将ActivityThread相关的资源加载到新进程；</li>
<li>ActivityManagerService向新生成的ActivityThread进程，通过Binder方式发送生成服务的请求；</li>
<li>ActivityThread启动运行服务;</li>
</ol>
<p>在整个startService过程，从进程角度看服务启动过程</p>
<ul>
<li><strong>Process A进程</strong>：是指调用startService命令所在的进程，也就是启动服务的发起端进程，比如点击桌面App图标，此处Process A便是Launcher所在进程。</li>
<li><strong>system_server进程</strong>：系统进程，是java framework框架的核心载体，里面运行了大量的系统服务，比如这里提供ApplicationThreadProxy（简称ATP），ActivityManagerService（简称AMS），这个两个服务都运行在system_server进程的不同线程中，由于ATP和AMS都是基于IBinder接口，都是binder线程，binder线程的创建与销毁都是由binder驱动来决定的，每个进程binder线程个数的上限为16。</li>
<li><strong>Zygote进程</strong>：是由<code>init</code>进程遍历.rc文件拉起来的，用于创建Java层进程的母体，所有的Java层进程都是由Zygote进程孵化而来；</li>
<li><strong>Remote Service进程</strong>：远程服务所在进程，是由Zygote进程孵化而来的用于运行Remote服务的进程。主线程主要负责Activity&#x2F;Service等组件的生命周期以及UI相关操作都运行在这个线程； 另外，每个App进程中至少会有两个binder线程 ApplicationThread(简称AT)和ActivityManagerProxy（简称AMP），当然还有其他线程，这里不是重点就不提了。</li>
</ul>
<p><img src="/typora-user-images/start_service_processes.jpg"></p>
<p>图中涉及3种IPC通信方式：<code>Binder</code>、<code>Socket</code>以及<code>Handler</code>，在图中分别用3种不同的颜色来代表这3种通信方式。一般来说，同一进程内的线程间通信采用的是 <a target="_blank" rel="noopener" href="http://gityuan.com/2015/12/26/handler-message/">Handler消息队列机制</a>，不同进程间的通信采用的是<a target="_blank" rel="noopener" href="http://gityuan.com/2015/10/31/binder-prepare/">binder机制</a>，另外与Zygote进程通信采用的<code>Socket</code>。</p>
<p>启动流程：</p>
<ol>
<li>Process A进程采用Binder IPC向system_server进程发起startService请求；</li>
<li>system_server进程接收到请求后，向zygote进程发送创建进程的请求；</li>
<li>zygote进程fork出新的子进程Remote Service进程；</li>
<li>Remote Service进程，通过Binder IPC向sytem_server进程发起attachApplication请求；</li>
<li>system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向remote Service进程发送scheduleCreateService请求；</li>
<li>Remote Service进程的binder线程在收到请求后，通过handler向主线程发送CREATE_SERVICE消息；</li>
<li>主线程在收到Message后，通过发射机制创建目标Service，并回调Service.onCreate()方法。</li>
</ol>
<p>到此，服务便正式启动完成。当创建的是本地服务或者服务所属进程已创建时，则无需经过上述步骤2、3，直接创建服务即可。</p>
<p>startService的生命周期为onCreate, onStartCommand, onDestroy,流程如下图</p>
<p><img src="/typora-user-images/service_lifeline.jpg"></p>
<p>由上图可见,造成ANR可能的原因有Binder full{step 7, 12}, MessageQueue(step 10), AMS Lock (step 13).</p>
<p>当进程启动Service其所在进程还没有启动时, 需要先启动其目标进程,流程如下图:</p>
<p><img src="/typora-user-images/start_service_process.jpg"></p>
<p>Window分为三种窗口应用程序窗口（1-99），子窗口（1000-1999），系统窗口（2000-2999），会根据其中的type值显示窗口次序窗口添加过程主要是，配置视图属性，还有Flag，最后通过WindowManager的addViews（）而方法的实现在WindowManagerImpl，而WindowManagerImpl最后回到WindowManagerGlobal中，WindowManagerGlobal中维护了三个列表，view列表，布局参数列表，ViewRootImpl列表，通过addToDisplay进行Binder通信，addToDisplay调用了WMS的addWindow（），将自身作为参数s（Session），每个应用程序对应一个Session，WMS通过ArrayList保存这些Session，WMS会为这个添加的窗口分配Surface，并确定显示次序，负责界面的是Surface，WMS会把管理的Surface交给SurfaceFlinger处理，SurfaceFlinger会将这些Sufrace混合并绘制到屏幕上。</p>
<p>WMS的创建会直接调用WMS的main方法</p>
<h3 id="为什么不去强转呢？子类去转父类啊"><a href="#为什么不去强转呢？子类去转父类啊" class="headerlink" title="为什么不去强转呢？子类去转父类啊"></a>为什么不去强转呢？子类去转父类啊</h3><p>在一些开发中我们发现如果我们拿到了子类，但子类缺没有父类的方法，我们想调用父类特有的方法该怎么办，<strong>为什么不去强转呢？子类去转父类啊</strong></p>
<h3 id="Android使用观察者模式进行解耦"><a href="#Android使用观察者模式进行解耦" class="headerlink" title="Android使用观察者模式进行解耦"></a>Android使用观察者模式进行解耦</h3><p>编写观察者模式接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.seres.adapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObservableData</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Observable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ObservableData</span><span class="params">(T initData)</span> &#123;</span><br><span class="line">        data = initData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        setChanged();</span><br><span class="line">        notifyObservers(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h2><p>懒加载时会遇到什么问题</p>
<p>看一下这张图</p>
<p><img src="/typora-user-images/image-20241227150120431.png" alt="image-20241227150120431"></p>
<p>这个时候调用getKey会lateinit property key has not been initialized</p>
<p>因为RwKeyFun的构造函数要等待BaseKeyFuncation完成构造函数走完，那么怎么可以等待初始化完成后在调用呢</p>
<p>可以对setKey进行重写，在重写中去调用getKey的相关方法</p>
<h2 id="SOMEIP-ITEH-ONE"><a href="#SOMEIP-ITEH-ONE" class="headerlink" title="SOMEIP ITEH-ONE"></a>SOMEIP ITEH-ONE</h2><p>在使用SOMEIP工具进行模拟的时候需要把模拟端的网络适配器修改为对应的IP，如果你要模拟服务器你就修改为服务器的IP如果你要模拟客户端就修改成客户端的IP</p>

    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <p>Copyright © 2020 <a class="flink" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>-<a class="flink" target="_blank" rel="noopener" href="https://github.com/sanjinhub/hexo-theme-geek">Geek</a>.
        <label class="el-switch el-switch-green el-switch-sm" style="vertical-align: sub;">
            <input type="checkbox" name="switch" id="update_style">
            <span class="el-switch-style"></span>
        </label>
<!--         <script type="text/javascript">
        var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
        document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
        </script> -->
    </p>
</div>
<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="CmCti21ooOOIzFOhEyFkFvR0-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="FqiyUqbg7McKN2eG0MCewupf">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>
</body>

</html>